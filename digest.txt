Directory structure:
└── /./
    ├── background.js
    ├── llmExtractor.ts
    ├── options.js
    ├── contentScript.ts
    ├── docs/
    │   ├── TESTING.md
    │   ├── README.md
    │   ├── CURRENT_STATUS.md
    │   ├── IMPLEMENTATION_PLAN.md
    │   └── REFACTORING.md
    ├── README.md
    ├── types.ts
    ├── styles/
    │   └── pdf-overlay.css
    ├── background.ts
    ├── package.json
    ├── manifest.json
    ├── lib/
    ├── tsconfig.json
    ├── options.html
    ├── eslint.config.js
    ├── llmExtractor.js
    ├── CLAUDE.md
    ├── contentScript.js
    ├── options.ts
    └── REFACTORING.md

================================================
File: /background.js
================================================
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
// Ensure service worker activates
console.log('Background service worker starting...');
// Basic background service worker
chrome.runtime.onInstalled.addListener(function () {
    console.log('Extension installed');
    // Store the OpenAI key for LLM-based claim extraction
    // TODO: In the future, this will be configured by the user in options.html
    // The extension will fall back to rule-based extraction if this key is invalid
    chrome.storage.local.set({
        openAiKey: 'OPENAI-API-KEY-GOES-HERE' // Development key placeholder - replace with actual key during testing
    });
});
// Exa API configuration for source verification
// TODO: Move to user-configurable storage in future version
var EXA_API_KEY = 'EXA-API-KEY-GOES-HERE'; // Development key placeholder - replace with actual key during testing
var EXA_API_URL = 'https://api.exa.ai/search';
/**
 * Verify a claim using Exa's API to find supporting sources
 * This is the core function that connects claims to reliable sources
 *
 * @param claim - The text of the claim to verify
 * @returns Promise resolving to an array of search results with source information
 */
function verifyClaimWithExa(claim) {
    return __awaiter(this, void 0, void 0, function () {
        var response, data, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 3, , 4]);
                    return [4 /*yield*/, fetch(EXA_API_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': "Bearer ".concat(EXA_API_KEY)
                            },
                            body: JSON.stringify({
                                query: claim,
                                numResults: 3, // Limit to 3 sources for UI simplicity
                                type: 'neural' // Use neural search for better semantic understanding
                            })
                        })];
                case 1:
                    response = _a.sent();
                    if (!response.ok) {
                        throw new Error("Exa API error: ".concat(response.status));
                    }
                    return [4 /*yield*/, response.json()];
                case 2:
                    data = _a.sent();
                    return [2 /*return*/, data.results];
                case 3:
                    error_1 = _a.sent();
                    console.error('Error verifying claim:', error_1);
                    throw error_1;
                case 4: return [2 /*return*/];
            }
        });
    });
}
// Listen for messages from content script
// This handles the communication between the content script (UI) and background service worker (API calls)
chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
    if (request.type === 'VERIFY_CLAIM') {
        // Process the claim verification request
        // This keeps API calls in the background script for better security and performance
        verifyClaimWithExa(request.claim.text)
            .then(function (results) {
            console.log('Verification results:', results);
            sendResponse({ success: true, results: results });
        })
            .catch(function (error) {
            // Handle API errors gracefully
            console.error('Verification failed:', error);
            sendResponse({ success: false, error: error.message });
        });
        return true; // Return true to indicate we'll respond asynchronously
    }
    return true; // Always return true from the listener
});


================================================
File: /llmExtractor.ts
================================================
/**
 * Interface for LLM extraction results containing claims and confidence scores
 */
interface LLMExtractionResult {
  claims: string[];         // Array of extracted factual claims
  confidence: number[];     // Corresponding confidence scores (0-1)
}

/**
 * Extracts factual claims from text using OpenAI's GPT-4
 * This provides more accurate claim detection than rule-based approaches
 * and includes confidence scoring for each claim
 * 
 * Enhanced with improved prompting to:
 * - Filter out subjective, speculative, and opinion-based statements
 * - Focus on verifiable claims with specific data and evidence
 * - Assess confidence based on factual clarity and specificity
 * - Prioritize claims that reference research, measurements, or established facts
 */
// Make the class global for content script access
const LLMExtractor = class {
  private apiKey: string;
  private maxTokens = 4000; // GPT-4 context window limit
  
  /**
   * Initialize the extractor with an OpenAI API key
   * @param apiKey - OpenAI API key
   */
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  public async extractClaimsFromChunk(text: string): Promise<LLMExtractionResult> {
    try {
      if (!this.apiKey || this.apiKey === '') {
        throw new Error('OpenAI API key not provided or empty');
      }
      
      // Validate API key format (should be a non-empty string starting with 'sk-')
      if (!this.apiKey.startsWith('sk-')) {
        throw new Error('Invalid OpenAI API key format');
      }
      
      console.log('Sending request to OpenAI API...');
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          model: 'gpt-4',
          messages: [{
            role: 'system',
            content: `Extract factual claims from the text. Return a JSON array where each item has:
              - claim: The exact claim text
              - confidence: 0-1 score of how clearly it's a factual claim (0.9+ for very clear factual claims with specific data, 0.7-0.9 for likely factual claims, below 0.7 for statements that might be factual but lack specificity)
              
              Only include clear, verifiable claims that could be fact-checked against reliable sources.
              
              EXCLUDE the following types of statements:
              - Opinions, subjective judgments, or matters of taste
              - Speculative statements containing "might," "may," "could," "possibly," etc.
              - Value judgments containing "good," "bad," "best," "worst," etc.
              - Relative or comparative claims without specific metrics
              - Personal beliefs starting with "I think," "I believe," etc.
              - Questions or hypotheticals
              - Future predictions
              - Claims about intentions or motivations
              - General claims without specificity
              
              INCLUDE statements that:
              - Contain specific numbers, dates, statistics, or measurements
              - Reference research, studies, or specific published findings
              - Make clear cause-effect assertions based on evidence
              - Describe specific historical events, discoveries, or observations
              - Reference specific organizations, people, or places in relation to verifiable actions
              - Make definitive statements about established processes or systems
              
              Prioritize precision, specificity, and verifiability in your selection.`
          }, {
            role: 'user',
            content: text
          }],
          temperature: 0.1
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const data = await response.json();
      if (!data || !data.choices || !data.choices[0] || !data.choices[0].message || !data.choices[0].message.content) {
        throw new Error('Invalid response format from OpenAI API');
      }
      
      const claims = data.choices[0].message.content;
      
      try {
        const parsed = JSON.parse(claims);
        
        if (!Array.isArray(parsed)) {
          throw new Error('Expected JSON array in response');
        }
        
        return {
          claims: parsed.map((p: any) => p.claim),
          confidence: parsed.map((p: any) => p.confidence)
        };
      } catch (parseError) {
        console.error('Failed to parse OpenAI response as JSON:', parseError);
        // Try to extract claims with regex as fallback
        const claimMatches = claims.match(/claim["\s:]+([^"]+)/gi);
        const confidenceMatches = claims.match(/confidence["\s:]+([0-9.]+)/gi);
        
        if (claimMatches) {
          const extractedClaims = claimMatches.map((m: string) => {
            const match = m.match(/claim["\s:]+(.+)/i);
            return match ? match[1].trim() : '';
          }).filter((c: string) => c);
          
          const extractedConfidences = confidenceMatches ? confidenceMatches.map((m: string) => {
            const match = m.match(/confidence["\s:]+([0-9.]+)/i);
            return match ? parseFloat(match[1]) : 0.5;
          }) : extractedClaims.map(() => 0.5);
          
          if (extractedClaims.length > 0) {
            return {
              claims: extractedClaims,
              confidence: extractedConfidences
            };
          }
        }
        
        throw new Error('Failed to parse claims from OpenAI response');
      }
    } catch (error) {
      console.error('LLM extraction failed:', error);
      return { claims: [], confidence: [] };
    }
  }

  private chunkText(text: string, maxLength: number = 3000): string[] {
    // Split into paragraphs
    const paragraphs = text.split(/\n\s*\n/);
    const chunks: string[] = [];
    let currentChunk = '';

    for (const paragraph of paragraphs) {
      if ((currentChunk + paragraph).length > maxLength) {
        if (currentChunk) chunks.push(currentChunk);
        currentChunk = paragraph;
      } else {
        currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
      }
    }
    if (currentChunk) chunks.push(currentChunk);
    return chunks;
  }

  /**
   * Extract factual claims from text with confidence scores
   * Handles large texts by chunking and processing in parallel
   * 
   * @param text - The text to analyze for factual claims
   * @returns Promise resolving to claims and confidence scores
   */
  public async extractClaims(text: string): Promise<LLMExtractionResult> {
    // Split large text into manageable chunks to fit within token limits
    const chunks = this.chunkText(text);
    
    // Process all chunks in parallel for better performance
    const results = await Promise.all(
      chunks.map(chunk => this.extractClaimsFromChunk(chunk))
    );

    // Merge results from all chunks into a single result
    return {
      claims: results.flatMap(r => r.claims),
      confidence: results.flatMap(r => r.confidence)
    };
  }
}

================================================
File: /options.js
================================================
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
// Test the Exa API key
function testExaKey(key) {
    return __awaiter(this, void 0, void 0, function () {
        var response, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, fetch('https://api.exa.ai/search', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': "Bearer ".concat(key)
                            },
                            body: JSON.stringify({
                                query: 'test query',
                                numResults: 1
                            })
                        })];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, response.ok];
                case 2:
                    error_1 = _a.sent();
                    return [2 /*return*/, false];
                case 3: return [2 /*return*/];
            }
        });
    });
}
// Test the OpenAI API key
function testOpenAIKey(key) {
    return __awaiter(this, void 0, void 0, function () {
        var response, error_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, fetch('https://api.openai.com/v1/models', {
                            headers: {
                                'Authorization': "Bearer ".concat(key)
                            }
                        })];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, response.ok];
                case 2:
                    error_2 = _a.sent();
                    return [2 /*return*/, false];
                case 3: return [2 /*return*/];
            }
        });
    });
}
// Save settings to storage
function saveSettings() {
    return __awaiter(this, void 0, void 0, function () {
        var settings, tabs, _i, tabs_1, tab;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    settings = {
                        exaKey: document.getElementById('exaKey').value,
                        openaiKey: document.getElementById('openaiKey').value,
                        highlightsEnabled: document.getElementById('highlightsEnabled').checked,
                        sidebarEnabled: document.getElementById('sidebarEnabled').checked,
                        darkMode: document.getElementById('darkMode').checked,
                        excludedDomains: document.getElementById('excludedDomains')
                            .value
                            .split('\n')
                            .map(function (d) { return d.trim(); })
                            .filter(function (d) { return d; })
                    };
                    return [4 /*yield*/, chrome.storage.local.set(settings)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, chrome.tabs.query({})];
                case 2:
                    tabs = _a.sent();
                    for (_i = 0, tabs_1 = tabs; _i < tabs_1.length; _i++) {
                        tab = tabs_1[_i];
                        if (tab.id) {
                            chrome.tabs.sendMessage(tab.id, { type: 'SETTINGS_UPDATED', settings: settings });
                        }
                    }
                    return [2 /*return*/];
            }
        });
    });
}
// Load settings from storage
function loadSettings() {
    return __awaiter(this, void 0, void 0, function () {
        var settings;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, chrome.storage.local.get({
                        exaKey: '',
                        openaiKey: '',
                        highlightsEnabled: true,
                        sidebarEnabled: false,
                        darkMode: false,
                        excludedDomains: []
                    })];
                case 1:
                    settings = _a.sent();
                    document.getElementById('exaKey').value = settings.exaKey;
                    document.getElementById('openaiKey').value = settings.openaiKey;
                    document.getElementById('highlightsEnabled').checked = settings.highlightsEnabled;
                    document.getElementById('sidebarEnabled').checked = settings.sidebarEnabled;
                    document.getElementById('darkMode').checked = settings.darkMode;
                    document.getElementById('excludedDomains').value =
                        settings.excludedDomains.join('\n');
                    return [2 /*return*/];
            }
        });
    });
}
// Update status message
function updateStatus(elementId, success, message) {
    var element = document.getElementById(elementId);
    if (element) {
        element.textContent = message;
        element.className = "status ".concat(success ? 'success' : 'error');
    }
}
// Initialize
document.addEventListener('DOMContentLoaded', function () {
    var _a, _b, _c;
    loadSettings();
    // Test Exa API key
    (_a = document.getElementById('testExaKey')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', function () { return __awaiter(_this, void 0, void 0, function () {
        var key, success;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    key = document.getElementById('exaKey').value;
                    return [4 /*yield*/, testExaKey(key)];
                case 1:
                    success = _a.sent();
                    updateStatus('exaKeyStatus', success, success ? '✓ API key is valid' : '✗ Invalid API key');
                    return [2 /*return*/];
            }
        });
    }); });
    // Test OpenAI API key
    (_b = document.getElementById('testOpenAIKey')) === null || _b === void 0 ? void 0 : _b.addEventListener('click', function () { return __awaiter(_this, void 0, void 0, function () {
        var key, success;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    key = document.getElementById('openaiKey').value;
                    return [4 /*yield*/, testOpenAIKey(key)];
                case 1:
                    success = _a.sent();
                    updateStatus('openaiKeyStatus', success, success ? '✓ API key is valid' : '✗ Invalid API key');
                    return [2 /*return*/];
            }
        });
    }); });
    // Save settings
    (_c = document.getElementById('saveSettings')) === null || _c === void 0 ? void 0 : _c.addEventListener('click', function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, saveSettings()];
                case 1:
                    _a.sent();
                    updateStatus('saveStatus', true, 'Settings saved!');
                    setTimeout(function () {
                        var element = document.getElementById('saveStatus');
                        if (element)
                            element.textContent = '';
                    }, 2000);
                    return [2 /*return*/];
            }
        });
    }); });
});


================================================
File: /contentScript.ts
================================================
// Declare PDF.js types
declare const pdfjsLib: {
  getDocument: (url: string) => { promise: Promise<any> };
  GlobalWorkerOptions: { workerSrc: string };
};

// Global variable to store all discovered claims
let extractedClaims: Claim[] = [];

// We'll use our own LLMExtractionResult interface and directly reference the LLMExtractor class
// from llmExtractor.ts (which will be loaded via script tag in manifest.json)
interface LLMExtractionResult {
  claims: string[];
  confidence: number[];
}

// No need to redeclare LLMExtractor here since it will be loaded from llmExtractor.js

// Define types inline since we can't use modules in content scripts
interface Claim {
  id: number;
  text: string;
  cleanText: string;
  context: {
    page: number;
    paragraph: number;
  };
  relevance: number;
  confidence?: number; // Added confidence score from LLM
}

interface ClaimDetectionResult {
  claims: Claim[];
  totalProcessed: number;
}

// PDF handling types and class
interface PDFPageContent {
  text: string;
  viewport: any;
  pageNum: number;
}

interface PDFTextItem {
  str: string;
  transform: number[];
  pageNum?: number;
  paragraph?: number;
}

interface StoredTextItem {
  str: string;
  pageNum: number;
  paragraph: number;
}

class PDFHandler {
  private url: string;
  private pdfDoc: any = null;
  private textItems: StoredTextItem[] = [];
  
  constructor(url: string) {
    this.url = url;
    // @ts-ignore
    pdfjsLib.GlobalWorkerOptions.workerSrc = chrome.runtime.getURL('pdf.worker.min.js');
  }

  async init(): Promise<void> {
    try {
      // @ts-ignore
      const loadingTask = pdfjsLib.getDocument(this.url);
      this.pdfDoc = await loadingTask.promise;
    } catch (error) {
      console.error('Error loading PDF:', error);
      throw error;
    }
  }

  async getPageContent(pageNum: number): Promise<PDFPageContent> {
    const page = await this.pdfDoc.getPage(pageNum);
    const viewport = page.getViewport({ scale: 1.0 });
    const textContent = await page.getTextContent();
    
    let currentParagraph = 0;
    let lastY: number | undefined;
    
    textContent.items.forEach((item: PDFTextItem) => {
      if (lastY !== undefined && Math.abs(item.transform[5] - lastY) > 15) {
        currentParagraph++;
      }
      lastY = item.transform[5];
      
      this.textItems.push({
        str: item.str,
        pageNum,
        paragraph: currentParagraph
      });
    });

    const text = textContent.items.map((item: PDFTextItem) => item.str).join(' ');
    return { text, viewport, pageNum };
  }

  async getAllContent(): Promise<string> {
    const numPages = this.pdfDoc.numPages;
    const pageTexts: string[] = [];

    for (let i = 1; i <= numPages; i++) {
      const { text } = await this.getPageContent(i);
      pageTexts.push(text);
    }

    return pageTexts.join('\n\n');
  }

  findTextLocation(text: string): StoredTextItem | null {
    for (let i = 0; i < this.textItems.length; i++) {
      const windowSize = 100;
      const chunk = this.textItems.slice(i, i + windowSize)
        .map(item => item.str)
        .join(' ');
      
      if (chunk.includes(text)) {
        return this.textItems[i];
      }
    }
    return null;
  }
}

/**
 * Extracts and processes factual claims from webpage content
 * This class uses rule-based heuristics to identify claims
 * It serves as a fallback when LLM-based extraction is unavailable
 */
class ContentExtractor {
  private claimCounter = 0;

  /**
   * Get main content from webpage, excluding navigation, footers, etc.
   * Focuses on paragraphs with substantive content by filtering out
   * short text elements that are likely UI components
   */
  public getMainContent(): string[] {
    console.log('Getting main content from webpage');
    
    // Get all text-containing elements
    const allElements = document.body.querySelectorAll('p, h1, h2, h3, h4, h5, h6, article, section, div');
    console.log(`Found ${allElements.length} potential text elements`);
    
    // Filter to elements that likely contain substantive content
    const contentElements = Array.from(allElements).filter(el => {
      const text = el.textContent || '';
      
      // Skip elements with very little text
      if (text.length < 30) return false;
      
      // Skip elements that are likely navigation, headers, footers, etc.
      const tagName = el.tagName.toLowerCase();
      if (tagName === 'div') {
        // Only include divs that are likely content containers, not layout divs
        // Check for content characteristics
        const hasEnoughText = text.length > 100;
        const hasSentences = text.split('.').length > 2;
        const hasParagraphChild = el.querySelector('p') !== null;
        
        return hasEnoughText && hasSentences && !hasParagraphChild;
      }
      
      // Accept paragraph and article elements by default
      return true;
    });
    
    console.log(`Filtered down to ${contentElements.length} content elements`);
    
    // Tag elements for easier identification later
    contentElements.forEach((el, index) => {
      if (!el.getAttribute('data-deepcite-id')) {
        el.setAttribute('data-deepcite-id', `content-${index}`);
        
        // Add a subtle border to help visualize what's being analyzed
        (el as HTMLElement).style.border = '1px dashed rgba(47, 128, 237, 0.3)';
      }
    });
    
    // Extract text from these elements
    const contentTexts = contentElements
      .map(el => el.textContent as string)
      .filter(text => text.length > 30);
    
    // Also always include paragraph elements as a fallback
    const paragraphs = Array.from(document.getElementsByTagName('p'))
      .filter(p => p.textContent && p.textContent.length > 50)
      .map(p => p.textContent as string);
    
    // Combine and deduplicate manually instead of using Set
    const allTexts = [...contentTexts, ...paragraphs];
    const uniqueTexts: string[] = [];
    
    for (const text of allTexts) {
      if (!uniqueTexts.includes(text)) {
        uniqueTexts.push(text);
      }
    }
    
    console.log(`Final content extraction: ${uniqueTexts.length} text blocks`);
    return uniqueTexts;
  }

  /**
   * Enhanced claim detection using more precise rules
   * - Filters out subjective language and opinions
   * - Skips questions, emotional language, and speculative content
   * - Focuses on statements with factual indicators
   * - Requires presence of evidence-based language
   * - Detects statements with numeric data and proper nouns
   */
  private isLikelyClaim(sentence: string): boolean {
    // Skip very short sentences
    if (sentence.length < 20) return false;
    
    // Skip sentences with subjective/speculative language
    const hasSubjectiveIndicators = /\b(I think|I believe|in my opinion|I feel|it might be|it may be|we believe|probably|possibly|maybe|perhaps|likely|unlikely|seems to|could be|might be|may be|allegedly|supposedly|apparently)\b/i.test(sentence);
    if (hasSubjectiveIndicators) return false;
    
    // Skip questions (often not factual claims)
    if (sentence.trim().endsWith('?')) return false;
    
    // Skip emotional/opinion phrases
    const hasEmotionalLanguage = /\b(beautiful|ugly|wonderful|terrible|best|worst|amazing|awful|good|bad|love|hate|favorite|great|excellent|poor|superior|inferior)\b/i.test(sentence);
    if (hasEmotionalLanguage) return false;
    
    // Check for numbers
    const hasNumbers = /\d/.test(sentence);
    
    // Check for proper nouns (simplified)
    const hasProperNouns = /\s[A-Z][a-z]+/.test(sentence);
    
    // Enhanced claim indicators - expanded for better detection of fact-like language
    const hasClaimIndicators = /(found|showed|discovered|reported|according to|study|research|analysis|evidence|data|results|concluded|suggests|indicates|confirms|demonstrates|proves|supported by|measured|observed|conducted|survey|experiments|calculations|statistics|percent|percentage|proportion|scientific|researchers|scientists|experts|published|journal|paper|investigate|examine|analyze|determine|established|verify|confirmed|identify|document|record|reveal|show that|demonstrate that|indicate that|prove that|establish that|verified that)/i.test(sentence);
    
    // Force some sentences to be considered claims only if they don't have subjective indicators
    if (!hasSubjectiveIndicators && !hasEmotionalLanguage && (
        sentence.includes('climate') || 
        sentence.includes('research') || 
        sentence.includes('study') || 
        sentence.includes('found') ||
        sentence.includes('data') ||
        sentence.includes('showed'))) {
      return true;
    }

    return (hasNumbers || hasProperNouns) && hasClaimIndicators;
  }

  /**
   * Split text into sentences, handling common abbreviations
   */
  private splitIntoSentences(text: string): string[] {
    // Basic sentence splitting with some abbreviation handling
    return text
      .replace(/([.?!])\s+(?=[A-Z])/g, "$1|")
      .split("|")
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

  /**
   * Calculate relevance score based on enhanced heuristics
   * - Boosts statements with specific data, percentages, and statistics
   * - Rewards research references and evidence-based language
   * - Penalizes subjective elements like first-person pronouns
   * - Adjusts for future tense and non-verifiable content
   */
  private calculateRelevance(sentence: string): number {
    let score = 0.5; // Base score
    
    // Boost score for numbers (important for factual claims)
    if (/\d/.test(sentence)) score += 0.15;
    
    // Give higher boost for percentages and statistics
    if (/\d+(\.\d+)?%|\d+ percent|\d+ percentage/i.test(sentence)) score += 0.1;
    
    // Boost for proper nouns (entities being discussed)
    if (/\s[A-Z][a-z]+/.test(sentence)) score += 0.1;
    
    // Substantial boost for research/evidence indicators
    if (/(study|research|found|showed|evidence|data|results|published|journal|paper)/i.test(sentence)) score += 0.15;
    
    // Boost for specific verifiable terms
    if (/(according to|reported by|measured|observed|conducted|statistics|researchers|scientists)/i.test(sentence)) score += 0.1;
    
    // Penalize very long sentences (more likely to contain mixed content)
    if (sentence.length > 200) score -= 0.1;
    
    // Penalize sentences with first-person pronouns (often opinions)
    if (/\b(I|we|our|my)\b/i.test(sentence)) score -= 0.15;
    
    // Slight penalty for future tense (less verifiable)
    if (/\b(will|going to|shall|would)\b/i.test(sentence)) score -= 0.05;

    return Math.min(Math.max(score, 0), 1); // Clamp between 0 and 1
  }

  /**
   * Extract claims from the current webpage
   */
  public async extractClaims(maxClaims: number = 5): Promise<ClaimDetectionResult> {
    const paragraphs = this.getMainContent();
    const claims: Claim[] = [];
    let totalProcessed = 0;

    // Fall back to rule-based approach if LLM fails or isn't available
    for (let pIndex = 0; pIndex < paragraphs.length; pIndex++) {
      const sentences = this.splitIntoSentences(paragraphs[pIndex]);
      
      for (const sentence of sentences) {
        totalProcessed++;
        
        if (this.isLikelyClaim(sentence)) {
          const relevance = this.calculateRelevance(sentence);
          
          // Clean the text by removing references
          const cleanText = sentence.replace(/\[\d+\]/g, '');
          
          claims.push({
            id: ++this.claimCounter,
            text: sentence,
            cleanText,
            context: {
              page: 1,
              paragraph: pIndex
            },
            relevance
          });

          if (claims.length >= maxClaims) {
            return { claims, totalProcessed };
          }
        }
      }
    }
    return { claims, totalProcessed };
  }
}

// Link to our external stylesheet that has all the styles
// Make sure to add this early to ensure styles are applied
function addStylesheet() {
  console.log('Adding stylesheet to document head');
  const existingStylesheets = document.querySelectorAll('link[href*="pdf-overlay.css"]');
  if (existingStylesheets.length > 0) {
    console.log('Stylesheet already exists, not adding again');
    return;
  }
  
  const linkToStyles = document.createElement('link');
  linkToStyles.rel = 'stylesheet';
  linkToStyles.href = chrome.runtime.getURL('styles/pdf-overlay.css');
  document.head.appendChild(linkToStyles);
  console.log('Stylesheet added:', linkToStyles.href);
}

// Creates a small sidebar toggle button fixed to the right edge of the screen
function createSidebarToggle() {
  const toggleBtn = document.createElement('button');
  toggleBtn.className = 'deepcite-sidebar-toggle';
  toggleBtn.textContent = '»';   // Arrow icon
  
  // Position it fixed on the right, about halfway down
  toggleBtn.style.position = 'fixed';
  toggleBtn.style.right = '0';
  toggleBtn.style.top = '50%';
  toggleBtn.style.transform = 'translateY(-50%)';
  toggleBtn.style.width = '32px';
  toggleBtn.style.height = '48px';
  toggleBtn.style.backgroundColor = 'var(--primary-color, #2F80ED)';
  toggleBtn.style.color = '#fff';
  toggleBtn.style.border = 'none';
  toggleBtn.style.borderRadius = '8px 0 0 8px'; // Round left corners
  toggleBtn.style.cursor = 'pointer';
  toggleBtn.style.zIndex = '99999';
  toggleBtn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
  toggleBtn.style.fontSize = '16px';
  toggleBtn.style.fontWeight = 'bold';
  toggleBtn.style.transition = 'all 0.3s ease';
  
  // On hover, make the button slightly larger
  toggleBtn.addEventListener('mouseenter', () => {
    toggleBtn.style.width = '36px';
    toggleBtn.style.backgroundColor = 'var(--primary-color-hover, #1c68d3)';
  });
  
  toggleBtn.addEventListener('mouseleave', () => {
    toggleBtn.style.width = '32px';
    toggleBtn.style.backgroundColor = 'var(--primary-color, #2F80ED)';
  });
  
  // On click, open or close the claims overlay
  toggleBtn.addEventListener('click', () => {
    // First check if we need to run the analysis
    const hasRunAnalysis = toggleBtn.getAttribute('data-analysis-run') === 'true';
    const overlay = document.querySelector('.deepcite-claims-overlay') as HTMLElement;
    
    if (!hasRunAnalysis) {
      // If analysis hasn't been run yet, run it
      toggleBtn.setAttribute('data-analysis-run', 'true');
      toggleBtn.textContent = '⟳'; // Loading indicator
      toggleBtn.style.opacity = '0.8';
      
      // Run the appropriate analysis based on content type
      if (document.contentType === 'application/pdf' || 
          window.location.pathname.toLowerCase().endsWith('.pdf')) {
        // For PDFs
        chrome.storage.local.get(['openaiKey', 'useLLMExtraction'], result => {
          analyzePDF(result.openaiKey, result.useLLMExtraction);
          // After analysis complete
          toggleBtn.textContent = '»';
          toggleBtn.style.opacity = '1';
        });
      } else {
        // For web pages
        chrome.storage.local.get(['openaiKey', 'useLLMExtraction'], async (result) => {
          // Use Content Extractor to get main content
          const extractor = new ContentExtractor();
          await runExtraction(extractor, result.openaiKey, result.useLLMExtraction);
          // After analysis complete
          toggleBtn.textContent = '»';
          toggleBtn.style.opacity = '1';
        });
      }
    }
    
    // Toggle overlay visibility with improved animation
    if (overlay) {
      if (overlay.classList.contains('closed') || overlay.style.display === 'none') {
        // First display the overlay but keep it closed
        overlay.style.display = 'block';
        
        // Force a reflow to ensure the transition works
        overlay.offsetHeight;
        
        // Now remove classes to trigger animation
        setTimeout(() => {
          overlay.classList.remove('closed', 'minimized');
          toggleBtn.textContent = '«'; // Change arrow direction
        }, 10);
      } else {
        if (overlay.classList.contains('minimized')) {
          // If minimized, expand it
          overlay.classList.remove('minimized');
          toggleBtn.textContent = '«';
        } else {
          // If expanded, minimize it
          overlay.classList.add('minimized');
          toggleBtn.textContent = '»';
        }
      }
    }
  });
  
  document.body.appendChild(toggleBtn);
  return toggleBtn;
}

// Add stylesheet immediately
addStylesheet();

// Helper function to determine color based on confidence level
function getConfidenceColor(confidence: number): string {
  if (confidence >= 0.8) return 'var(--high-confidence)';   // High confidence - green
  if (confidence >= 0.5) return 'var(--medium-confidence)'; // Medium confidence - yellow/amber
  return 'var(--low-confidence)';                           // Low confidence - red
}

// Function to add a claim to the unified claims overlay
function addClaimToOverlay(overlay: HTMLElement, claim: Claim, sources: any[] = []) {
  const claimDiv = document.createElement('div');
  claimDiv.className = 'deepcite-claim-item';
  claimDiv.setAttribute('data-claim-id', claim.id.toString());
  
  // Create the basic claim information
  let claimHTML = `
    ${(claim as any).pdfLocation ? `
      <div class="pdf-claim-location">
        Page ${(claim as any).pdfLocation.pageNum}, Paragraph ${(claim as any).pdfLocation.paragraph + 1}
      </div>
    ` : ''}
    <div class="deepcite-claim-text">${claim.text}</div>
    ${claim.confidence !== undefined ? `
      <div class="deepcite-claim-confidence">
        <span style="font-weight: bold;">Certainty:</span>
        <span class="confidence-meter" style="
          width: ${Math.round(claim.confidence * 100)}px;
          background-color: ${getConfidenceColor(claim.confidence)};
        "></span>
        <span class="confidence-text" style="color: ${getConfidenceColor(claim.confidence)}; font-weight: 500;">
          ${Math.round(claim.confidence * 100)}%
        </span>
      </div>
    ` : ''}
  `;
  
  // Add the verify button if sources haven't been checked yet
  if (sources.length === 0) {
    claimHTML += `
      <button class="verify-claim-btn" data-claim-id="${claim.id}">
        Verify
      </button>
      <div class="deepcite-claim-sources" style="margin-top: 8px; display: none;">
        <!-- Sources will go here after user verifies -->
      </div>
    `;
  } else {
    // If sources are already provided, show them
    claimHTML += `
      <div class="deepcite-claim-sources" style="margin-top: 8px;">
        <div class="deepcite-claim-sources-header">Sources (${sources.length}):</div>
    `;
    
    // Add all sources to the claim or show "no sources" message
    if (sources.length === 0) {
      claimHTML += `
        <div class="deepcite-claim-source-item">
          <div class="deepcite-source-title">
            <span style="color: #666; font-style: italic;">No relevant sources found</span>
          </div>
        </div>
      `;
    } else {
      sources.forEach((source: any, index: number) => {
        // Skip "no sources" placeholder entries
        if (source.title === "No relevant sources found" || source.url === "#") {
          claimHTML += `
            <div class="deepcite-claim-source-item">
              <div class="deepcite-source-title">
                <span style="color: #666; font-style: italic;">No relevant sources found</span>
              </div>
            </div>
          `;
        } else {
          claimHTML += `
            <div class="deepcite-claim-source-item">
              <div class="deepcite-source-title">
                <a href="${source.url}" target="_blank">${source.title}</a>
                <span class="deepcite-source-confidence">(${Math.round(source.score * 100)}% confidence)</span>
              </div>
              ${source.highlights && source.highlights.length > 0 ? 
                `<div class="deepcite-source-highlight">"${source.highlights[0]}"</div>` : ''}
              ${index < sources.length - 1 ? '<hr class="deepcite-source-divider">' : ''}
            </div>
          `;
        }
      });
    }
    
    // Close the sources div
    claimHTML += `</div>`;
  }
  
  claimDiv.innerHTML = claimHTML;
  
  // Add click handler to highlight the claim text in the document
  claimDiv.addEventListener('click', (e) => {
    // Don't trigger if clicking the verify button
    if ((e.target as HTMLElement).classList.contains('verify-claim-btn')) {
      return;
    }
    
    // Find the element with the claim text and scroll to it
    const elements = document.querySelectorAll('.exa-claim-highlight');
    for (let i = 0; i < elements.length; i++) {
      const elem = elements[i];
      if (elem.textContent?.includes(claim.cleanText)) {
        elem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        elem.classList.add('exa-claim-highlight-flash');
        setTimeout(() => {
          elem.classList.remove('exa-claim-highlight-flash');
        }, 1500);
        break;
      }
    }
  });
  
  overlay.appendChild(claimDiv);
}

// Set up a single event listener to handle all "Verify" button clicks
function setupVerifyButtonHandlers(overlay: HTMLElement) {
  overlay.addEventListener('click', (ev) => {
    const btn = ev.target as HTMLElement;
    if (btn.classList.contains('verify-claim-btn')) {
      ev.stopPropagation(); // Prevent triggering the parent claim click event
      const claimId = btn.getAttribute('data-claim-id');
      if (!claimId) return;
      
      // Disable the button and show loading spinner
      btn.innerHTML = '<span class="exa-loading" style="margin-right: 8px;"></span>Verifying...';
      btn.setAttribute('disabled', 'true');
      btn.style.opacity = '0.8';
      btn.style.cursor = 'wait';
      
      // Find the claim in extractedClaims
      const targetClaim = extractedClaims.find(c => c.id.toString() === claimId);
      if (!targetClaim) {
        btn.textContent = 'Error';
        return;
      }
      
      // Now call Exa with that single claim
      chrome.runtime.sendMessage({
        type: 'VERIFY_CLAIM',
        claim: targetClaim
      }, (response) => {
        if (response && response.success && response.results) {
          // Show sources section
          const claimItem = btn.closest('.deepcite-claim-item') as HTMLElement;
          const sourcesDiv = claimItem?.querySelector('.deepcite-claim-sources') as HTMLElement;
          
          if (sourcesDiv) {
            // Update the sources div
            updateClaimSources(claimId, response.results, sourcesDiv);
            sourcesDiv.style.display = 'block';
          }
          
          // Remove the verify button
          btn.remove();
        } else if (response && response.error === 'DAILY_LIMIT_REACHED') {
          // Handle daily limit reached error
          const claimItem = btn.closest('.deepcite-claim-item') as HTMLElement;
          const sourcesDiv = claimItem?.querySelector('.deepcite-claim-sources') as HTMLElement;
          
          if (sourcesDiv) {
            sourcesDiv.style.display = 'block';
            sourcesDiv.innerHTML = `
              <div style="color: #dc3545; padding: 10px; background: rgba(220, 53, 69, 0.1); border-radius: 6px; margin-top: 10px;">
                <strong>⚠️ ${response.message}</strong>
                <div style="margin-top: 5px; font-size: 14px;">
                  You can adjust limits in the extension options.
                </div>
              </div>
            `;
          }
          
          // Update button to show options
          btn.textContent = 'Options';
          btn.removeAttribute('disabled');
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          
          // Change button to open options page when clicked
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            chrome.runtime.openOptionsPage();
          }, { once: true });
        } else {
          // Show general error state
          btn.textContent = 'Retry';
          btn.removeAttribute('disabled');
          btn.style.opacity = '1';
          btn.style.cursor = 'pointer';
          
          // Show error message
          const claimItem = btn.closest('.deepcite-claim-item') as HTMLElement;
          const sourcesDiv = claimItem?.querySelector('.deepcite-claim-sources') as HTMLElement;
          
          if (sourcesDiv) {
            sourcesDiv.style.display = 'block';
            sourcesDiv.innerHTML = `
              <div style="color: #666; font-style: italic; padding: 10px;">
                No sources could be found. Please try again later.
              </div>
            `;
          }
        }
      });
    }
  });
}

// Update the sources section for a claim
function updateClaimSources(claimId: string, sources: any[], sourcesDiv: HTMLElement) {
  if (!sources.length) {
    sourcesDiv.innerHTML = '<div class="deepcite-claim-sources-header">Sources:</div><em>No sources found</em>';
    return;
  }
  
  let html = `<div class="deepcite-claim-sources-header">Sources (${sources.length}):</div>`;
  sources.forEach((source, index) => {
    if (source.title === "No relevant sources found" || source.url === "#") {
      html += `
        <div class="deepcite-claim-source-item">
          <div class="deepcite-source-title">
            <span style="color: #666; font-style: italic;">No relevant sources found</span>
          </div>
        </div>
      `;
    } else {
      html += `
        <div class="deepcite-claim-source-item">
          <div class="deepcite-source-title">
            <a href="${source.url}" target="_blank">${source.title}</a>
            <span class="deepcite-source-confidence">(${Math.round(source.score * 100)}% confidence)</span>
          </div>
          ${source.highlights && source.highlights.length > 0 ? 
            `<div class="deepcite-source-highlight">"${source.highlights[0]}"</div>` : ''}
          ${index < sources.length - 1 ? '<hr class="deepcite-source-divider">' : ''}
        </div>
      `;
    }
  });
  sourcesDiv.innerHTML = html;
}

// Function to highlight text and add tooltip with source information
// This is the core UI component that makes claims interactive
// and displays verification results to the user
// Helper function to create a consistent DEEPCITE badge
function createDeepCiteBadge(): HTMLElement {
  const badge = document.createElement('span');
  badge.className = 'deepcite-badge';
  badge.textContent = 'DEEPCITE';
  badge.title = 'This element contains a factual claim verified by DeepCite';
  
  // We're now using CSS defined in pdf-overlay.css
  // No need to add event listeners as they're handled via CSS :hover
  
  return badge;
}

function highlightClaim(claim: Claim, sources: any[]): boolean {
  console.log('Starting highlight process for claim:', claim.cleanText);
  
  // Check if this claim already has a data-claim-id attribute set in the DOM
  // to avoid duplicate highlights
  const existingHighlight = document.querySelector(`[data-claim-id="${claim.id}"]`);
  if (existingHighlight) {
    console.log('This claim is already highlighted, skipping duplicate highlight');
    return true;
  }
  
  // Try to find the claim in the actual page content
  const paragraphs = document.getElementsByTagName('p');
  console.log('Found paragraphs:', paragraphs.length);
  
  let foundMatch = false;
  for (let i = 0; i < paragraphs.length; i++) {
    const p = paragraphs[i];
    const cleanParagraphText = p.textContent?.replace(/\[\d+\]/g, '') || '';
    
    if (cleanParagraphText.includes(claim.cleanText)) {
      console.log('Found matching paragraph!', p.getAttribute('data-deepcite-id'));
      foundMatch = true;
      
      try {
        // Enhanced styling for better visibility
        p.style.backgroundColor = 'rgba(47, 128, 237, 0.2)'; // Increased opacity
        p.style.borderLeft = '4px solid rgba(47, 128, 237, 0.6)'; // Thicker border, more opacity
        p.style.padding = '8px'; // Increased padding
        p.style.cursor = 'pointer';
        p.style.transition = 'all 0.25s ease';
        p.style.borderRadius = '3px'; // Subtle rounded corners
        p.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.05)'; // Subtle shadow
        
        // Mark this paragraph
        p.setAttribute('data-claim-id', claim.id.toString());
        
        // Add the improved DEEPCITE badge
        const deepciteBadge = createDeepCiteBadge();
        
        // Add confidence score to the badge if available
        if (claim.confidence !== undefined) {
          const confidencePercent = Math.round(claim.confidence * 100);
          deepciteBadge.title = `Confidence score: ${confidencePercent}%`;
        }
        
        // Insert at the beginning of the paragraph
        if (p.firstChild) {
          p.insertBefore(deepciteBadge, p.firstChild);
        } else {
          p.appendChild(deepciteBadge);
        }
        
        console.log('Applied enhanced styles to paragraph');
      } catch (err) {
        console.error('Error highlighting paragraph:', err);
      }
      
      // Create direct hover handler on the paragraph
      let currentTooltip: HTMLElement | null = null;
      let tooltipTimeout: number | null = null;
      let currentSourceIndex = 0;
      
      // Function to update tooltip content
      const updateTooltip = () => {
        if (!currentTooltip) return;
        
        // We'll update the tooltip to provide a better view of multiple sources
        let tooltipHTML = '';
        
        // Add claim confidence if available - with visual meter
        if (claim.confidence !== undefined) {
          tooltipHTML += `
            <div class="exa-claim-confidence" style="margin-bottom: 10px; padding: 6px 8px; background: rgba(47, 128, 237, 0.05); border-radius: 6px; font-size: 13px;">
              <span style="font-weight: bold;">Certainty:</span> 
              <span style="display: inline-block; height: 8px; border-radius: 4px; margin: 0 6px; width: ${Math.round(claim.confidence * 100)}px; background-color: ${getConfidenceColor(claim.confidence)};">
              </span>
              <span style="font-weight: 500; margin-left: 4px; color: ${getConfidenceColor(claim.confidence)}">
                ${Math.round(claim.confidence * 100)}%
              </span>
            </div>
          `;
        }
        
        // Add sources header
        tooltipHTML += `<div style="font-weight: 600; margin-bottom: 10px; color: #333;">
          Sources (${sources.length})
        </div>`;
        
        // Display sources
        if (sources.length <= 2) {
          // Show all sources in a compact view
          tooltipHTML += sources.map((source, index) => {
            const srcFavicon = `https://www.google.com/s2/favicons?domain=${new URL(source.url).hostname}`;
            return `
              <div style="margin-bottom: 10px; padding: 6px;">
                <div style="display: flex; align-items: center; margin-bottom: 6px;">
                  <img src="${srcFavicon}" alt="Source icon" style="width: 16px; height: 16px; margin-right: 8px; border-radius: 2px;">
                  <strong>${source.title}</strong>
                  <span style="display: inline-block; padding: 2px 6px; background: rgba(47, 128, 237, 0.05); border-radius: 4px; font-size: 12px; margin-left: 8px; color: #666;">
                    ${Math.round(source.score * 100)}%
                  </span>
                </div>
                <a href="${source.url}" target="_blank" style="color: #007AFF; text-decoration: none;">View source</a>
                ${index < sources.length - 1 ? '<hr style="margin: 10px 0; border: 0; border-top: 1px solid #eee;">' : ''}
              </div>
            `;
          }).join('');
        } else {
          // Use pagination for 3+ sources
          const source = sources[currentSourceIndex];
          const srcFavicon = `https://www.google.com/s2/favicons?domain=${new URL(source.url).hostname}`;
          
          tooltipHTML += `
            <div style="margin-bottom: 10px; padding: 6px;">
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <img src="${srcFavicon}" alt="Source icon" style="width: 16px; height: 16px; margin-right: 8px; border-radius: 2px;">
                <strong>${source.title}</strong>
                <span style="display: inline-block; padding: 2px 6px; background: rgba(47, 128, 237, 0.05); border-radius: 4px; font-size: 12px; margin-left: 8px; color: #666;">
                  ${Math.round(source.score * 100)}%
                </span>
              </div>
              <a href="${source.url}" target="_blank" style="color: #007AFF; text-decoration: none;">View source</a>
            </div>
            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 10px; padding-top: 8px; border-top: 1px solid #eee;">
              <button id="prev-btn" ${currentSourceIndex === 0 ? 'disabled' : ''} style="background: #f8f9fa; border: 1px solid #eee; color: #333; cursor: pointer; padding: 4px 10px; border-radius: 6px;">
                ← Previous
              </button>
              <span>${currentSourceIndex + 1}/${sources.length}</span>
              <button id="next-btn" ${currentSourceIndex === sources.length - 1 ? 'disabled' : ''} style="background: #f8f9fa; border: 1px solid #eee; color: #333; cursor: pointer; padding: 4px 10px; border-radius: 6px;">
                Next →
              </button>
            </div>
          `;
        }
        
        currentTooltip.innerHTML = tooltipHTML;
        
        // Add event listeners to buttons
        if (sources.length > 2) {
          const prevBtn = currentTooltip.querySelector('#prev-btn');
          const nextBtn = currentTooltip.querySelector('#next-btn');
          
          if (prevBtn) {
            prevBtn.addEventListener('click', () => {
              if (currentSourceIndex > 0) {
                currentSourceIndex--;
                updateTooltip();
              }
            });
          }
          
          if (nextBtn) {
            nextBtn.addEventListener('click', () => {
              if (currentSourceIndex < sources.length - 1) {
                currentSourceIndex++;
                updateTooltip();
              }
            });
          }
        }
      };
      
      const clearTooltipTimeout = () => {
        if (tooltipTimeout) {
          clearTimeout(tooltipTimeout);
          tooltipTimeout = null;
        }
      };
      
      const startTooltipTimeout = () => {
        clearTooltipTimeout();
        tooltipTimeout = window.setTimeout(() => {
          if (currentTooltip) {
            currentTooltip.remove();
            currentTooltip = null;
          }
        }, 300);
      };
      
      // Add hover handler directly to the paragraph
      p.addEventListener('mouseenter', () => {
        clearTooltipTimeout();
        
        // Remove any existing tooltips
        const existingTooltip = document.querySelector('.exa-tooltip');
        if (existingTooltip) existingTooltip.remove();
        
        const newTooltip = document.createElement('div');
        newTooltip.className = 'exa-tooltip';
        newTooltip.style.position = 'fixed';
        newTooltip.style.background = 'white';
        newTooltip.style.border = '1px solid #e0e0e0';
        newTooltip.style.boxShadow = '0 8px 24px rgba(0,0,0,0.1)';
        newTooltip.style.padding = '14px 18px';
        newTooltip.style.borderRadius = '8px';
        newTooltip.style.fontSize = '14px';
        newTooltip.style.maxWidth = '320px';
        newTooltip.style.zIndex = '999999';
        newTooltip.style.color = '#333';
        newTooltip.style.backdropFilter = 'blur(10px)';
        newTooltip.style.opacity = '0';
        newTooltip.style.transform = 'translateY(8px)';
        newTooltip.style.transition = 'opacity 0.25s, transform 0.25s';
        newTooltip.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
        newTooltip.style.lineHeight = '1.5';
        
        // Position the tooltip
        const rect = p.getBoundingClientRect();
        newTooltip.style.top = `${rect.bottom + 5}px`;
        newTooltip.style.left = `${rect.left}px`;
        
        document.body.appendChild(newTooltip);
        currentTooltip = newTooltip;
        
        // Add animation
        setTimeout(() => {
          newTooltip.style.opacity = '1';
          newTooltip.style.transform = 'translateY(0)';
        }, 10);
        
        // Initial tooltip content
        updateTooltip();
        
        // Add hover handlers to tooltip
        newTooltip.addEventListener('mouseenter', clearTooltipTimeout);
        newTooltip.addEventListener('mouseleave', startTooltipTimeout);
      });
      
      p.addEventListener('mouseleave', startTooltipTimeout);
      
      // Only process the first matching paragraph
      break;
    }
  }
  
  // Return whether we found and highlighted a match
  return foundMatch;
}

async function isPDF(): Promise<boolean> {
  return document.contentType === 'application/pdf' || 
         window.location.pathname.toLowerCase().endsWith('.pdf');
}

/**
 * Create a draggable claims overlay panel
 * Improved with smooth animations and draggable functionality
 * @param isPDF Whether this is being used in PDF mode
 * @returns The overlay HTML element
 */
async function createClaimsOverlay(isPDF = false) {
  console.log('Creating claims overlay, isPDF:', isPDF);
  
  // Clean up any temporary UI elements when creating/reopening overlay
  cleanupEphemeralElements();
  
  // Check if overlay already exists
  let overlay = document.querySelector('.deepcite-claims-overlay') as HTMLElement;
  console.log('Existing overlay found:', !!overlay);
  
  if (overlay) {
    // If overlay exists, keep it in its current state (closed/minimized)
    // We'll control visibility with the toggle button now
    console.log('Using existing overlay');
    
    // Update the header to show we're processing again
    const headerSmall = overlay.querySelector('.deepcite-claims-header small');
    if (headerSmall) {
      headerSmall.textContent = 'Processing...';
    }
    
    return overlay;
  }
  
  console.log('Creating new overlay');
  overlay = document.createElement('div');
  overlay.className = 'deepcite-claims-overlay';
  
  // Add close button
  const closeButton = document.createElement('button');
  closeButton.className = 'deepcite-overlay-close';
  closeButton.textContent = '×';
  closeButton.title = 'Toggle sidebar';
  
  // Toggle button handling
  closeButton.addEventListener('click', (e) => {
    e.stopPropagation();
    
    if (overlay.classList.contains('minimized')) {
      // If minimized, expand it back
      overlay.classList.remove('minimized');
      closeButton.title = 'Toggle sidebar';
    } else {
      // If expanded, minimize it
      overlay.classList.add('minimized');
      closeButton.title = 'Expand sidebar';
    }
  });
  
  // Add double-click to fully close
  closeButton.addEventListener('dblclick', (e) => {
    e.stopPropagation();
    overlay.classList.add('closed');
    
    // Set a timeout to fully hide it after animation completes
    setTimeout(() => {
      if (overlay.classList.contains('closed')) {
        overlay.style.display = 'none';
        
        // Clean up any ephemeral UI elements when closing panel
        cleanupEphemeralElements();
      }
    }, 300); // match the CSS transition time
  });
  
  overlay.appendChild(closeButton);
  
  // Add header
  const header = document.createElement('div');
  header.className = 'deepcite-claims-header';
  header.innerHTML = `
    <h3>Detected Claims</h3>
    <small>Processing...</small>
  `;
  overlay.appendChild(header);
  
  // Make the overlay draggable using the header as the handle
  makeDraggable(overlay, header);
  
  // Add a "fully close" button at the bottom of the panel with improved styling
  const closeCompletelyButton = document.createElement('button');
  closeCompletelyButton.className = 'deepcite-close-panel-button';
  closeCompletelyButton.textContent = 'Close Panel';
  
  closeCompletelyButton.addEventListener('click', () => {
    overlay.classList.add('closed');
    
    // Set a timeout to fully hide it after animation completes
    setTimeout(() => {
      if (overlay.classList.contains('closed')) {
        overlay.style.display = 'none';
        
        // Clean up any ephemeral UI elements when closing panel
        cleanupEphemeralElements();
      }
    }, 300); // match the CSS transition time
  });
  
  overlay.appendChild(closeCompletelyButton);
  
  document.body.appendChild(overlay);
  
  // Hide the overlay by default - will be shown via the toggle button
  overlay.style.display = 'none';
  overlay.classList.add('closed');
  
  return overlay;
}

/**
 * Helper function to make an element draggable
 * @param element The element to make draggable
 * @param handle The drag handle (usually the header)
 */
function makeDraggable(element: HTMLElement, handle: HTMLElement) {
  let posX = 0, posY = 0, posLeft = 0, posTop = 0;
  
  const dragMouseDown = (e: MouseEvent) => {
    e.preventDefault();
    
    // Get starting positions
    posLeft = element.offsetLeft;
    posTop = element.offsetTop;
    posX = e.clientX;
    posY = e.clientY;
    
    // Add event listeners for drag and release
    document.addEventListener('mousemove', elementDrag);
    document.addEventListener('mouseup', closeDragElement);
    
    // Add dragging class for styling
    element.classList.add('dragging');
  };
  
  const elementDrag = (e: MouseEvent) => {
    e.preventDefault();
    
    // Calculate the new position
    const dx = posX - e.clientX;
    const dy = posY - e.clientY;
    posX = e.clientX;
    posY = e.clientY;
    
    // Check if the new position would be within screen bounds
    const newTop = element.offsetTop - dy;
    const newLeft = element.offsetLeft - dx;
    
    // Stay within viewport 
    const buffer = 20; // Minimum distance from edge
    
    if (newTop >= buffer && newTop + element.offsetHeight <= window.innerHeight - buffer) {
      element.style.top = `${newTop}px`;
    }
    
    if (newLeft >= buffer && newLeft + element.offsetWidth <= window.innerWidth - buffer) {
      element.style.left = `${newLeft}px`;
    }
  };
  
  const closeDragElement = () => {
    // Stop moving when mouse button is released
    document.removeEventListener('mousemove', elementDrag);
    document.removeEventListener('mouseup', closeDragElement);
    
    // Remove dragging class
    element.classList.remove('dragging');
  };
  
  // Attach the mousedown event listener to the handle
  handle.addEventListener('mousedown', dragMouseDown);
  
  // Apply initial draggable styling
  handle.style.cursor = 'move';
  element.style.position = 'fixed';
}

/**
 * Cleans up temporary UI elements when opening/closing the panel
 * This ensures a clean state
 */
function cleanupEphemeralElements() {
  // Remove any floating tooltips
  const tooltips = document.querySelectorAll('.exa-tooltip');
  tooltips.forEach(tooltip => tooltip.remove());
  
  // Remove any temporary status indicators
  const indicators = document.querySelectorAll('[data-temporary-indicator]');
  indicators.forEach(indicator => indicator.remove());
}

async function analyzePDF(openaiKey: string, useLLMExtraction: boolean = true) {
  const overlay = await createClaimsOverlay(true);
  
  // Get the Exa API key from storage
  const { exaKey } = await new Promise<{exaKey: string}>(resolve => {
    chrome.storage.local.get(['exaKey'], (result) => resolve(result as {exaKey: string}));
  });
  
  // Check for missing API keys
  if (!exaKey || exaKey === '') {
    console.error('Exa API key is missing');
    
    // Update the overlay to show an error
    const header = overlay.querySelector('.deepcite-claims-header small');
    if (header) {
      header.textContent = 'API key missing. Please set in options.';
    }
    
    // Add an error message to the overlay
    const errorDiv = document.createElement('div');
    errorDiv.className = 'deepcite-claim-item';
    errorDiv.innerHTML = `
      <div class="deepcite-claim-text" style="color: #dc3545; text-align: center; padding: 15px;">
        Exa API key is missing. Please set it in the extension options.
      </div>
      <button id="open-options-btn" style="margin: 10px auto; display: block; padding: 8px 16px; background: #f8f9fa; border: 1px solid #eee; color: #333; cursor: pointer; border-radius: 6px;">
        Open Options
      </button>
    `;
    
    overlay.appendChild(errorDiv);
    
    // Add click handler for the options button
    const optionsBtn = errorDiv.querySelector('#open-options-btn');
    if (optionsBtn) {
      optionsBtn.addEventListener('click', () => {
        chrome.runtime.openOptionsPage();
      });
    }
    
    return;
  }
  
  // Create a temporary status indicator for analysis
  const statusIndicator = document.createElement('div');
  statusIndicator.setAttribute('data-temporary-indicator', 'true');
  statusIndicator.style.position = 'fixed';
  statusIndicator.style.top = '20px';
  statusIndicator.style.right = '20px';
  statusIndicator.style.padding = '12px 16px';
  statusIndicator.style.backgroundColor = 'var(--primary-color)';
  statusIndicator.style.color = 'white';
  statusIndicator.style.zIndex = '99999';
  statusIndicator.style.borderRadius = 'var(--border-radius-md)';
  statusIndicator.style.fontWeight = 'bold';
  statusIndicator.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
  statusIndicator.style.transition = 'all 0.5s cubic-bezier(0.16, 1, 0.3, 1)';
  statusIndicator.style.fontFamily = 'var(--font-family)';
  statusIndicator.style.fontSize = '14px';
  statusIndicator.style.display = 'flex';
  statusIndicator.style.alignItems = 'center';
  statusIndicator.style.opacity = '0';
  statusIndicator.style.transform = 'translateY(-10px)';
  statusIndicator.innerHTML = '<span style="margin-right: 8px; font-size: 16px;">📄</span> Analyzing PDF...';
  document.body.appendChild(statusIndicator);
  
  // Animate in
  setTimeout(() => {
    statusIndicator.style.opacity = '1';
    statusIndicator.style.transform = 'translateY(0)';
  }, 10);
  
  try {
    const pdfHandler = new PDFHandler(window.location.href);
    await pdfHandler.init();
    const content = await pdfHandler.getAllContent();
    
    let useAI = false;
    
    // Try to use LLM extraction if OpenAI key is available and LLM extraction is enabled
    if (openaiKey && openaiKey !== '' && useLLMExtraction) {
      try {
        console.log('Testing LLM extraction for PDF...');
        const llmExtractor = new LLMExtractor(openaiKey);
        const testResult = await llmExtractor.extractClaimsFromChunk("This is a test claim.");
        
        if (testResult && testResult.claims.length > 0) {
          console.log('LLM extraction successful, will use it for PDF content');
          useAI = true;
          
          // Add a temporary indicator showing which extraction mode is used
          const extractionIndicator = document.createElement('div');
          extractionIndicator.setAttribute('data-temporary-indicator', 'true');
          extractionIndicator.style.position = 'fixed';
          extractionIndicator.style.bottom = '20px';
          extractionIndicator.style.right = '20px';
          extractionIndicator.style.padding = '8px 12px';
          extractionIndicator.style.backgroundColor = 'rgba(47, 128, 237, 0.8)';
          extractionIndicator.style.color = 'white';
          extractionIndicator.style.zIndex = '99998';
          extractionIndicator.style.borderRadius = 'var(--border-radius-md)';
          extractionIndicator.style.fontWeight = '500';
          extractionIndicator.style.fontSize = '13px';
          extractionIndicator.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
          extractionIndicator.style.fontFamily = 'var(--font-family)';
          extractionIndicator.innerHTML = '🧠 Using AI Extraction';
          document.body.appendChild(extractionIndicator);
          
          // Automatically remove after 5 seconds
          setTimeout(() => extractionIndicator.remove(), 5000);
          
          // Process full content with LLM extraction
          const fullResults = await llmExtractor.extractClaims(content);
          
          if (fullResults && fullResults.claims.length > 0) {
            // Add context information to each claim
            const claims = fullResults.claims.map((text, index) => ({
              id: index + 1,
              text,
              cleanText: text.replace(/\[\d+\]/g, ''), // Remove reference numbers if present
              context: {
                page: 1, // We'll update this later
                paragraph: 0
              },
              relevance: 0.8, // Default high relevance since LLM already filtered
              confidence: fullResults.confidence[index] || 0.7 // Use confidence from LLM or default
            }));
            
            // Update the header of the overlay
            const header = overlay.querySelector('.deepcite-claims-header small');
            if (header) {
              header.textContent = `${claims.length} claims found (AI-extracted)`;
            }
            
            // Process the claims
            processPDFClaims(claims, pdfHandler, overlay);
          } else {
            console.log('LLM extraction returned no claims, falling back to rule-based');
            useAI = false;
          }
        } else {
          console.log('LLM test failed, falling back to rule-based extraction');
        }
      } catch (error) {
        console.error('LLM extraction failed, using rule-based approach:', error);
        useAI = false;
      }
    } else {
      if (useLLMExtraction && (!openaiKey || openaiKey === '')) {
        console.log('LLM extraction enabled but OpenAI key missing, using rule-based extraction');
      } else {
        console.log('Using rule-based extraction (LLM extraction disabled in settings)');
      }
    }
    
    // Use rule-based approach if LLM failed or wasn't attempted
    if (!useAI) {
      console.log('Using rule-based extraction for PDF');
      
      // Add a temporary indicator showing which extraction mode is used
      const extractionIndicator = document.createElement('div');
      extractionIndicator.setAttribute('data-temporary-indicator', 'true');
      extractionIndicator.style.position = 'fixed';
      extractionIndicator.style.bottom = '20px';
      extractionIndicator.style.right = '20px';
      extractionIndicator.style.padding = '8px 12px';
      extractionIndicator.style.backgroundColor = 'rgba(100, 100, 100, 0.8)';
      extractionIndicator.style.color = 'white';
      extractionIndicator.style.zIndex = '99998';
      extractionIndicator.style.borderRadius = 'var(--border-radius-md)';
      extractionIndicator.style.fontWeight = '500';
      extractionIndicator.style.fontSize = '13px';
      extractionIndicator.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
      extractionIndicator.style.fontFamily = 'var(--font-family)';
      extractionIndicator.innerHTML = '📊 Using Rule-Based Extraction';
      document.body.appendChild(extractionIndicator);
      
      // Automatically remove after 5 seconds
      setTimeout(() => extractionIndicator.remove(), 5000);
      
      const extractor = new ContentExtractor();
      const extractionResult = await extractor.extractClaims(10);
      
      // Add confidence scores to all claims
      for (const claim of extractionResult.claims) {
        claim.confidence = 0.7; // Set a default confidence score
      }
      
      // Update the header of the overlay
      const header = overlay.querySelector('.deepcite-claims-header small');
      if (header) {
        header.textContent = `${extractionResult.claims.length} claims found (rule-based)`;
      }
      
      processPDFClaims(extractionResult.claims, pdfHandler, overlay);
    }
    
    // Update status indicator to show completion
    statusIndicator.innerHTML = '<span style="margin-right: 8px; font-size: 16px;">✓</span> PDF Analysis Complete';
    
  } catch (error) {
    console.error('PDF analysis failed:', error);
    
    // Update status indicator to show error
    statusIndicator.style.backgroundColor = '#dc3545';
    statusIndicator.innerHTML = '<span style="margin-right: 8px; font-size: 16px;">❌</span> PDF Analysis Failed';
  }
  
  // Remove status indicator after animation
  setTimeout(() => {
    statusIndicator.style.opacity = '0';
    statusIndicator.style.transform = 'translateY(-10px)';
    setTimeout(() => statusIndicator.remove(), 500);
  }, 5000);
}

// Helper function to process PDF claims
async function processPDFClaims(claims: Claim[], pdfHandler: PDFHandler, overlay: HTMLElement) {
  // Store the PDF claims globally to access from verify button handlers
  extractedClaims = [];
  
  // Sort claims by confidence for better presentation
  const sortedClaims = [...claims].sort((a, b) => {
    const confA = a.confidence !== undefined ? a.confidence : 0;
    const confB = b.confidence !== undefined ? b.confidence : 0;
    return confB - confA; // Sort in descending order
  });
  
  // Apply more strict filtering for PDF claims
  for (const claim of sortedClaims) {
    // Skip claims with low fact certainty (increased threshold)
    if (claim.confidence !== undefined && claim.confidence < 0.65) {
      console.log(`Skipping low confidence claim (${claim.confidence}): ${claim.text.substring(0, 50)}...`);
      continue;
    }
    
    // Skip claims that have subjective language patterns
    if (/\b(I think|I believe|in my opinion|we feel|might be|may be|probably|possibly|maybe|perhaps|could be|allegedly)\b/i.test(claim.text)) {
      console.log(`Skipping subjective claim: ${claim.text.substring(0, 50)}...`);
      continue;
    }
    
    // Find location in PDF to add to claim data
    const location = pdfHandler.findTextLocation(claim.cleanText);
    const pdfClaim = {...claim, pdfLocation: location};
    
    // Add to our global claims collection
    extractedClaims.push(pdfClaim);
    
    // Add to the overlay with the verify button
    addClaimToOverlay(overlay, pdfClaim);
    
    // For PDFs, override the click handler to navigate to the page
    const claimItem = overlay.querySelector(`.deepcite-claim-item[data-claim-id="${pdfClaim.id}"]`);
    if (claimItem && location) {
      claimItem.addEventListener('click', (e) => {
        // Don't navigate if clicking the verify button
        if ((e.target as HTMLElement).classList.contains('verify-claim-btn')) {
          return;
        }
        
        // Most PDF viewers support #page=N for navigation
        window.location.hash = `#page=${location.pageNum}`;
      });
    }
  }
  
  // Set up the verify button handlers
  setupVerifyButtonHandlers(overlay);
  
  // Ensure the overlay is visible
  overlay.classList.remove('closed', 'minimized');
  overlay.style.display = 'block';
}

// Main initialization
chrome.storage.local.get(['openaiKey', 'exaKey', 'highlightsEnabled', 'useLLMExtraction'], async (result) => {
  // Log the key availability and settings (but not the actual value for security)
  console.log('OpenAI key available:', !!result.openaiKey && result.openaiKey !== '');
  console.log('Exa key available:', !!result.exaKey && result.exaKey !== '');
  console.log('Highlights enabled:', result.highlightsEnabled !== false); // Default to true if undefined
  console.log('Using LLM extraction:', result.useLLMExtraction === true && !!result.openaiKey);
  
  // Create the overlay ahead of time (it will remain hidden)
  const isPdfPage = await isPDF();
  await createClaimsOverlay(isPdfPage);
  
  // Create the sidebar toggle button (which replaces the analyze buttons)
  const toggleBtn = createSidebarToggle();
  
  // Check for missing API keys - we'll handle this when the toggle is clicked
  if (!result.exaKey || result.exaKey === '') {
    console.warn('Exa API key is missing');
    
    // We'll still show the button, but it will display an error when clicked
    toggleBtn.title = 'DeepCite (API key missing)';
    toggleBtn.style.backgroundColor = '#dc3545'; // Red to indicate error
    
    // Add an alert message to the sidebar about missing API key
    const overlay = document.querySelector('.deepcite-claims-overlay') as HTMLElement;
    if (overlay) {
      const apiErrorDiv = document.createElement('div');
      apiErrorDiv.className = 'deepcite-claim-item';
      apiErrorDiv.innerHTML = `
        <div style="color: #dc3545; padding: 15px; background: rgba(220, 53, 69, 0.1); border-radius: 6px; text-align: center;">
          <span style="font-size: 24px; display: block; margin-bottom: 10px;">⚠️</span>
          <strong>Exa API Key Missing</strong>
          <p style="margin: 10px 0; font-size: 14px;">
            DeepCite requires an Exa API key to verify claims. Please add your key in the options page.
          </p>
          <button id="open-options-btn" style="margin: 10px auto; display: block; padding: 8px 16px; background: #f8f9fa; border: 1px solid #eee; color: #333; cursor: pointer; border-radius: 6px;">
            Open Options
          </button>
        </div>
      `;
      
      overlay.insertBefore(apiErrorDiv, overlay.querySelector('.deepcite-claim-item'));
      
      // Add click handler for the options button
      const optionsBtn = apiErrorDiv.querySelector('#open-options-btn');
      if (optionsBtn) {
        optionsBtn.addEventListener('click', () => {
          chrome.runtime.openOptionsPage();
        });
      }
    }
  }
});

// Any function that would create demonstration highlights with dummy sources
// has been completely removed - we now only display real API-verified results

async function runExtraction(extractor: ContentExtractor, openaiKey: string = '', useLLMExtraction: boolean = false) {
  console.log('Running extraction, LLM enabled:', useLLMExtraction && !!openaiKey);
  
  // Show which extraction mode is being used
  const extractionMode = (useLLMExtraction && !!openaiKey) ? 
    { text: '🧠 Using AI Extraction', color: 'rgba(47, 128, 237, 0.8)' } : 
    { text: '📊 Using Rule-Based Extraction', color: 'rgba(100, 100, 100, 0.8)' };
    
  // Add a temporary indicator showing the extraction mode
  const extractionIndicator = document.createElement('div');
  extractionIndicator.setAttribute('data-temporary-indicator', 'true');
  extractionIndicator.style.position = 'fixed';
  extractionIndicator.style.bottom = '20px';
  extractionIndicator.style.right = '20px';
  extractionIndicator.style.padding = '8px 12px';
  extractionIndicator.style.backgroundColor = extractionMode.color;
  extractionIndicator.style.color = 'white';
  extractionIndicator.style.zIndex = '99998';
  extractionIndicator.style.borderRadius = 'var(--border-radius-md)';
  extractionIndicator.style.fontWeight = '500';
  extractionIndicator.style.fontSize = '13px';
  extractionIndicator.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
  extractionIndicator.style.fontFamily = 'var(--font-family)';
  extractionIndicator.innerHTML = extractionMode.text;
  document.body.appendChild(extractionIndicator);
  
  // Automatically remove after 5 seconds
  setTimeout(() => extractionIndicator.remove(), 5000);
  
  // Create a temporary status indicator
  const statusIndicator = document.createElement('div');
  statusIndicator.setAttribute('data-temporary-indicator', 'true');
  statusIndicator.style.position = 'fixed';
  statusIndicator.style.top = '20px';
  statusIndicator.style.right = '20px';
  statusIndicator.style.padding = '12px 16px';
  statusIndicator.style.backgroundColor = 'var(--primary-color)';
  statusIndicator.style.color = 'white';
  statusIndicator.style.zIndex = '99999';
  statusIndicator.style.borderRadius = 'var(--border-radius-md)';
  statusIndicator.style.fontWeight = 'bold';
  statusIndicator.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
  statusIndicator.style.transition = 'all 0.5s cubic-bezier(0.16, 1, 0.3, 1)';
  statusIndicator.style.fontFamily = 'var(--font-family)';
  statusIndicator.style.fontSize = '14px';
  statusIndicator.style.display = 'flex';
  statusIndicator.style.alignItems = 'center';
  statusIndicator.style.opacity = '0';
  statusIndicator.style.transform = 'translateY(-10px)';
  statusIndicator.innerHTML = '<span style="margin-right: 8px; font-size: 16px;">🔍</span> DeepCite Analysis Active';
  document.body.appendChild(statusIndicator);
  
  // Animate in
  setTimeout(() => {
    statusIndicator.style.opacity = '1';
    statusIndicator.style.transform = 'translateY(0)';
  }, 10);
  
  // Remove status indicator after 5 seconds with animation
  setTimeout(() => {
    statusIndicator.style.opacity = '0';
    statusIndicator.style.transform = 'translateY(-10px)';
    setTimeout(() => statusIndicator.remove(), 500);
  }, 5000);
  
  // Find potential factual paragraphs to highlight
  const allParagraphs = document.querySelectorAll('p');
  const candidateParagraphs: HTMLElement[] = [];
  
  // Look for paragraphs that might contain factual claims
  for (let i = 0; i < allParagraphs.length; i++) {
    const p = allParagraphs[i] as HTMLElement;
    if (p.textContent && p.textContent.length > 80) {
      // Try to detect if this paragraph has factual content
      const text = p.textContent.toLowerCase();
      
      // Skip paragraphs with primarily subjective content
      const hasSubjectiveIndicators = /(I think|I believe|in my opinion|we feel|might be|may be|probably|possibly|maybe|perhaps|could be|allegedly)/i.test(text);
      const hasEmotionalLanguage = /(beautiful|ugly|wonderful|terrible|best|worst|amazing|awful|good|bad|love|hate|favorite)/i.test(text);
      
      if (hasSubjectiveIndicators && hasEmotionalLanguage) {
        continue; // Skip this paragraph
      }
      
      const hasNumbers = /\d/.test(text);
      const hasProperNouns = /\s[A-Z][a-z]+/.test(p.textContent);
      
      // Enhanced fact indicators with stronger emphasis on verifiable sources
      const hasFactIndicators = /(study|research|found|showed|according to|evidence|data|results|published|journal|measure|observe|statistic|percent|survey|experiment)/i.test(text);
      
      // Require more evidence for a paragraph to be considered factual
      if ((hasNumbers || (hasProperNouns && !hasSubjectiveIndicators)) && hasFactIndicators) {
        candidateParagraphs.push(p);
      }
    }
  }
  
  // Highlight up to 2 paragraphs maximum
  const paragraphsToHighlight = candidateParagraphs.slice(0, Math.min(2, candidateParagraphs.length));
  
  paragraphsToHighlight.forEach(p => {
    // Create a wrapper around the paragraph to allow removal
    const wrapper = document.createElement('div');
    wrapper.style.position = 'relative';
    wrapper.style.backgroundColor = 'rgba(47, 128, 237, 0.15)';
    wrapper.style.borderLeft = '3px solid rgba(47, 128, 237, 0.5)';
    wrapper.style.padding = '8px';
    wrapper.style.borderRadius = '3px';
    wrapper.style.marginBottom = '10px';
    wrapper.style.transition = 'all 0.3s ease';
    
    // Create close button
    const closeBtn = document.createElement('button');
    closeBtn.style.position = 'absolute';
    closeBtn.style.top = '5px';
    closeBtn.style.right = '5px';
    closeBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
    closeBtn.style.color = '#666';
    closeBtn.style.border = 'none';
    closeBtn.style.borderRadius = '50%';
    closeBtn.style.width = '20px';
    closeBtn.style.height = '20px';
    closeBtn.style.fontSize = '12px';
    closeBtn.style.cursor = 'pointer';
    closeBtn.style.display = 'flex';
    closeBtn.style.alignItems = 'center';
    closeBtn.style.justifyContent = 'center';
    closeBtn.textContent = '×';
    closeBtn.title = 'Remove highlight';
    
    // Add a consistent DEEPCITE badge
    const tagSpan = createDeepCiteBadge();
    tagSpan.style.marginBottom = '8px';
    tagSpan.style.marginLeft = '0';
    
    // Clone the paragraph
    const pClone = p.cloneNode(true) as HTMLElement;
    
    // Add event listeners
    closeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      wrapper.style.opacity = '0';
      setTimeout(() => wrapper.remove(), 300);
    });
    
    // Append everything
    wrapper.appendChild(closeBtn);
    wrapper.appendChild(tagSpan);
    wrapper.appendChild(pClone);
    
    // Replace the original paragraph with our wrapped version
    p.style.display = 'none'; // Hide original but keep in DOM for structure
    p.parentNode?.insertBefore(wrapper, p.nextSibling);
    
    // Auto-remove after 30 seconds if not interacted with
    setTimeout(() => {
      if (document.body.contains(wrapper)) {
        wrapper.style.opacity = '0';
        setTimeout(() => {
          if (document.body.contains(wrapper)) {
            wrapper.remove();
            p.style.display = ''; // Restore original paragraph
          }
        }, 300);
      }
    }, 30000);
  });
  
  // If no paragraphs were found, don't leave the user confused
  if (paragraphsToHighlight.length === 0) {
    console.log('No factual paragraphs detected for demonstration');
  }
  
  // Determine whether to use AI-based extraction
  let result;
  
  if (useLLMExtraction && openaiKey && openaiKey !== '') {
    try {
      console.log('Attempting LLM-based claim extraction for web page');
      const llmExtractor = new LLMExtractor(openaiKey);
      
      // Get the main content from the page
      const contentBlocks = extractor.getMainContent();
      const content = contentBlocks.join('\n\n');
      
      // Use LLM to extract claims
      const llmResults = await llmExtractor.extractClaims(content);
      
      if (llmResults && llmResults.claims.length > 0) {
        console.log('LLM extraction successful, found claims:', llmResults.claims.length);
        
        // Convert LLM results to our Claim format
        const claims = llmResults.claims.map((text, index) => ({
          id: index + 1,
          text,
          cleanText: text.replace(/\[\d+\]/g, ''), // Remove reference numbers if present
          context: {
            page: 1,
            paragraph: 0
          },
          relevance: 0.8, // Default high relevance since LLM already filtered
          confidence: llmResults.confidence[index] || 0.7 // Use confidence from LLM or default
        }));
        
        result = { claims, totalProcessed: contentBlocks.length };
      } else {
        console.log('LLM extraction returned no claims, falling back to rule-based');
        result = await extractor.extractClaims(10);
      }
    } catch (error) {
      console.error('LLM extraction failed, using rule-based approach:', error);
      result = await extractor.extractClaims(10);
    }
  } else {
    // Use rule-based approach
    console.log('Using rule-based claim extraction for web page');
    result = await extractor.extractClaims(10); // Increase to 10 claims for better results
  }
  
  // Store claims globally for later access by verify buttons
  extractedClaims = result.claims;
  
  console.log('Extraction found claims:', result.claims.length);
  
  // Create claims overlay
  const overlay = await createClaimsOverlay(false);
  overlay.style.display = 'block';
  
  if (result.claims.length > 0) {
    const header = overlay.querySelector('.deepcite-claims-header small');
    if (header) {
      const extractionMethod = (useLLMExtraction && openaiKey && openaiKey !== '') ? 'AI-extracted' : 'rule-based';
      header.textContent = `${result.claims.length} claims found (${extractionMethod})`;
    }
    
    // Process each claim
    for (const claim of result.claims) {
      // Add a default confidence score if one isn't present
      claim.confidence = claim.confidence ?? 0.7; // Use a consistent medium confidence score
      
      // Try to highlight the claim in the text
      highlightClaim(claim, []);
      
      // Add the claim to overlay with a verify button (not sources yet)
      addClaimToOverlay(overlay, claim);
    }
    
    // Set up the verify button handlers
    setupVerifyButtonHandlers(overlay);
    
    // Ensure overlay is visible
    overlay.classList.remove('closed', 'minimized');
    overlay.style.display = 'block';
  } else {
    // If no claims were found, display a clear message
    const header = overlay.querySelector('.deepcite-claims-header small');
    if (header) {
      header.textContent = `No claims found on this page`;
    }
    
    // Add a single "no claims found" message to the overlay
    const noClaimsDiv = document.createElement('div');
    noClaimsDiv.className = 'deepcite-claim-item';
    noClaimsDiv.innerHTML = `
      <div class="deepcite-claim-text" style="text-align: center; padding: 15px;">
        No factual claims were detected on this page.
      </div>
    `;
    overlay.appendChild(noClaimsDiv);
    
    // Ensure overlay is visible
    overlay.classList.remove('closed', 'minimized');
    overlay.style.display = 'block';
  }
}

================================================
File: /docs/TESTING.md
================================================
# Testing the Current Extension

## Setting Up for Testing

To test the Athena DeepCite extension in its current state:

1. **Build the TypeScript files**:
   ```bash
   npm run build
   ```

2. **Load the extension in Chrome**:
   - Open Chrome and navigate to `chrome://extensions/`
   - Enable "Developer mode" in the top-right corner
   - Click "Load unpacked"
   - Select the root folder of the repository (`/Users/samaydhawan/athena-deepcite`)

3. **Verify the extension is loaded**:
   - You should see "Deep Research Citation Verifier" in your list of extensions
   - Make sure it's enabled (toggle should be on)

## Testing on Web Pages

1. Navigate to a webpage with factual content (e.g., a news article, Wikipedia page, etc.)
2. Look for the "Analyze Webpage" button in the top-right corner of the page
3. Click the button to begin analysis
4. Wait for the analysis to complete (the button will show "Analysis Complete")
5. A claims overlay panel will appear on the right side, showing all detected factual claims
6. Factual claims in the text should be highlighted with a subtle blue background
7. Only claims with a fact certainty score above 40% will be highlighted and included in the overlay
8. Hover over a highlighted claim to see a tooltip with source information and certainty score
9. Click on a claim in the overlay panel to jump to its location in the text
10. Click the close button (×) in the top right of the overlay to minimize the panel
11. Click on a source link to open the original source document

**Good test pages**:
- Wikipedia articles on scientific topics
- News articles from major publications
- Research blog posts

## Testing on PDF Documents

1. Open a PDF document in Chrome
2. Look for the "Analyze PDF" button in the top-right corner
3. Click the button to begin analysis
4. Wait for the claims overlay panel to appear on the right side
5. The panel will show detected claims with fact certainty scores and source information
6. Only claims with a fact certainty score above 40% will be included in the overlay
7. Each claim shows a visual meter indicating its certainty level
8. Click on a claim to navigate to its location in the PDF
9. Click the close button (×) in the top right of the overlay to minimize the panel

**Good test PDFs**:
- Academic papers
- Reports with factual information
- News articles saved as PDFs

## Known Issues

- The extension may not correctly highlight claims in all webpages due to varying DOM structures
- Some websites block content scripts or have complex formatting that interferes with highlighting
- Very large PDFs may take a long time to process

## Troubleshooting

If the extension isn't working correctly:

1. **Check for errors in the console**:
   - Right-click on the page and select "Inspect"
   - Go to the "Console" tab
   - Look for any error messages related to the extension

2. **Verify the extension is loaded properly**:
   - Go to `chrome://extensions/`
   - Make sure the extension is enabled
   - Click the "Errors" button to see if there are any loading errors

3. **Rebuild the extension**:
   - Run `npm run build`
   - Go to `chrome://extensions/`
   - Click the refresh icon on the extension card

4. **Check for content restrictions**:
   - Some websites block content scripts or iframe content
   - Try the extension on a different website

## Reporting Issues

When reporting issues, please include:

1. The URL of the page where the issue occurred
2. Steps to reproduce the issue
3. Any error messages from the console
4. Browser version and operating system information

================================================
File: /docs/README.md
================================================
# Athena DeepCite Extension Development

## Current Status

The Athena DeepCite extension is a Chrome extension that:
- Detects factual claims in web pages and PDFs
- Highlights these claims for user interaction
- Uses Exa API to find supporting sources
- Provides confidence scores for claims and sources

During our work on Iteration 6 (Refactoring), we've created a plan for improving the codebase structure but haven't fully implemented it due to the specific requirements of Chrome extension architecture.

## Documentation Files

- **CURRENT_STATUS.md** - Describes the current state of the codebase
- **IMPLEMENTATION_PLAN.md** - Outlines the phased approach to refactoring
- **REFACTORING.md** - Details the architectural changes planned
- **TESTING.md** - Instructions for testing the extension

## Testing Instructions

To test the extension:

1. Make sure all files are in their original locations (not in src/ subdirectories)
2. Build the extension: `npm run build`
3. Load the unpacked extension in Chrome:
   - Go to `chrome://extensions/`
   - Enable Developer mode
   - Click "Load unpacked"
   - Select the extension directory

For detailed testing instructions, see `TESTING.md`.

## Technical Challenges

The main challenge in refactoring is that Chrome extensions have specific requirements:

1. **Module System**: Chrome extension content scripts run in a specific context that doesn't fully support ES modules
2. **Building**: We need a bundler like Webpack to properly handle the module dependencies
3. **Background/Content Script Communication**: Requires special handling for message passing

## Next Steps

1. Set up Webpack for bundling
2. Follow the implementation plan for refactoring
3. Test thoroughly after each phase

## Original Files

The core extension functionality is in these files:
- `contentScript.ts` - Main content script
- `background.ts` - Background service worker
- `llmExtractor.ts` - LLM-based extraction
- `types.ts` - Shared types

These files should remain in their original locations until we implement the bundling solution.

================================================
File: /docs/CURRENT_STATUS.md
================================================
# Current Status of Athena DeepCite

## Overview

Athena DeepCite is currently in a transition state. We've created a plan for refactoring but haven't fully implemented it yet. The documentation in the `docs/` directory outlines the future architecture and implementation steps.

## Current Files

The main codebase consists of:

- **contentScript.ts** - Main content script that runs in the browser
- **background.ts** - Background service worker for API calls
- **llmExtractor.ts** - Class for LLM-based claim extraction
- **types.ts** - Shared type definitions
- **options.html/ts** - Settings page (future functionality)
- **styles/pdf-overlay.css** - Styling for the extension

## Recent Improvements

We've made several enhancements to the extension:

1. **Manual Activation** - Analysis now only runs when the user explicitly clicks the "Analyze Webpage" or "Analyze PDF" button
2. **Fact Certainty Filtering** - Only claims with a fact certainty score above 40% are highlighted and displayed
3. **Visual Certainty Indicators** - Added visual meters to show the confidence score for each claim
4. **Unified Claims Panel** - Added a consistent side panel for both web pages and PDFs that shows all detected claims
5. **Modern UI** - Refreshed the visual design with more elegant animations, color scheme, and interactions
6. **Interactive Navigation** - Claims in the panel can be clicked to navigate to their location in the text

## How to Test

Please refer to `docs/TESTING.md` for detailed instructions on testing the extension.

## Refactoring Plans

We've created a comprehensive refactoring plan in `docs/IMPLEMENTATION_PLAN.md` and architectural details in `docs/REFACTORING.md`. The key points are:

1. Move to a modular architecture
2. Add webpack for bundling
3. Improve separation of concerns
4. Centralize configuration
5. Enhance code documentation

## Current Challenges

The main challenge is that Chrome extensions have specific limitations that affect our refactoring:

1. Module support is limited in Manifest V3
2. Direct imports between content and background scripts aren't possible
3. Message passing needs careful handling with complex data structures

## Next Steps

To continue development:

1. Review the implementation plan
2. Set up webpack for bundling
3. Follow the phased approach in the implementation plan

================================================
File: /docs/IMPLEMENTATION_PLAN.md
================================================
# Implementation Plan for Athena DeepCite Refactoring

This document outlines a comprehensive plan for refactoring the Athena DeepCite extension while ensuring it remains functional in a browser environment.

## Phase 1: Setup

1. **Add Webpack for bundling**
   - Install webpack and related packages
   - Create a webpack configuration file
   - Configure TypeScript to work with webpack

2. **Update project structure**
   - Create src directory with subdirectories
   - Move existing TypeScript files to appropriate locations
   - Set up path aliases in tsconfig.json

## Phase 2: Modularization

1. **Extract type definitions**
   - Move all interfaces to types.ts
   - Define common interfaces for extractors and handlers

2. **Refactor PDF handling**
   - Extract PDFHandler class to its own file
   - Create a dedicated PDFAnalyzer for UI components

3. **Refactor content extraction**
   - Implement IExtractor interface
   - Move ContentExtractor to its own file
   - Update LLMExtractor to implement the interface

4. **Create settings manager**
   - Centralize API key management
   - Add caching for better performance
   - Create utility functions for storage access

## Phase 3: Message Handling

1. **Refactor background script**
   - Implement message router pattern
   - Create handler functions for each message type
   - Document the message flow

2. **Update content script**
   - Simplify to focus on initialization and delegation
   - Add proper error handling
   - Improve logging for troubleshooting

## Phase 4: Build and Testing

1. **Update build process**
   - Create npm scripts for development and production builds
   - Add watch mode for faster iteration
   - Configure source maps for debugging

2. **Add ESLint and formatting**
   - Install and configure ESLint
   - Add TypeScript-specific rules
   - Create npm script for linting

3. **Test across browsers**
   - Test in Chrome
   - Test in Firefox (if supporting)
   - Verify functionality on different websites

## Phase 5: Documentation

1. **Update code documentation**
   - Add JSDoc comments to all public methods
   - Document message formats
   - Document extension architecture

2. **Create user documentation**
   - Update README with new features
   - Create troubleshooting guide
   - Document testing procedures

## Timeline

| Phase | Estimated Time | Description |
|-------|----------------|-------------|
| Phase 1 | 1-2 days | Setup bundling and project structure |
| Phase 2 | 2-3 days | Modularize the codebase |
| Phase 3 | 1-2 days | Refactor messaging system |
| Phase 4 | 1-2 days | Testing and build process |
| Phase 5 | 1 day | Documentation and final touches |

## Immediate Next Steps

1. Install webpack and configure it
2. Create the src directory structure
3. Update tsconfig.json for the new structure
4. Begin extracting modules while keeping the extension functional

================================================
File: /docs/REFACTORING.md
================================================
# Athena DeepCite Refactoring Guide

## Overview

This document outlines the approach to refactoring the Athena DeepCite codebase to improve maintainability, extensibility, and organization. Due to the Chrome extension architecture constraints, we have to carefully plan the refactoring to ensure it works in the browser environment.

## Recommended Architecture

### Directory Structure

```
/athena-deepcite/
├── src/
│   ├── extractors/
│   │   ├── contentExtractor.ts     # Rule-based claim extraction
│   │   └── llmExtractor.ts         # AI-powered claim extraction
│   ├── handlers/
│   │   ├── pdfHandler.ts           # PDF document processing
│   │   ├── pdfAnalyzer.ts          # PDF UI and analysis
│   │   └── webPageHandler.ts       # Web page UI and analysis
│   ├── utils/
│   │   └── settingsManager.ts      # API key and settings management
│   ├── types.ts                    # Shared type definitions
│   ├── contentScript.ts            # Main content script entry point
│   └── background.ts               # Background service worker
├── dist/                           # Compiled JavaScript
├── styles/                         # CSS styles
└── lib/                            # Third-party libraries
```

### Module Pattern

Because Chrome extensions in Manifest V3 have limitations with ES modules, we recommend using a module pattern:

```typescript
// Example for an extractor
namespace Extractors {
  export interface IClaimExtractor {
    extractClaims(text: string, maxClaims?: number): Promise<Types.ClaimDetectionResult>;
  }

  export class ContentExtractor implements IClaimExtractor {
    // Implementation
  }
}
```

This approach provides modularity while maintaining compatibility with Chrome extension architecture.

## Building the Extension

To build the extension with the new architecture:

1. Set up a bundler like Webpack or Rollup to handle module imports
2. Configure the bundler to output files in the format Chrome extensions expect
3. Use the `tsconfig.json` path mappings to maintain clean imports

Example Webpack configuration:

```javascript
module.exports = {
  entry: {
    contentScript: './src/contentScript.ts',
    background: './src/background.ts',
  },
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist'),
  },
  // More configuration...
};
```

## Testing the Extension

For testing during development:

1. Build the extension: `npm run build`
2. Load the unpacked extension in Chrome:
   - Go to `chrome://extensions/`
   - Enable "Developer mode" 
   - Click "Load unpacked"
   - Select the extension directory

Test both web pages and PDF documents to ensure all functionality works correctly.

## Implementation Notes

### Module Dependencies

Organize your dependencies carefully to avoid circular dependencies:

1. `types.ts` should have no imports
2. Modules should only import from modules "below" them in the dependency graph
3. Utility modules should be at the bottom of the graph

### Background/Content Script Communication

Use a structured message passing approach:

```typescript
// In content script
chrome.runtime.sendMessage({ 
  type: 'VERIFY_CLAIM', 
  claim 
}, response => {
  // Handle response
});

// In background script
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  switch (request.type) {
    case 'VERIFY_CLAIM':
      handleVerifyClaim(request, sendResponse);
      break;
    // Other cases...
  }
  return true; // Will respond asynchronously
});
```

## Migration Strategy

To migrate the codebase:

1. Create the new directory structure
2. Move functionality into appropriate modules
3. Refactor interdependent code to use the new structure
4. Update imports and references
5. Test thoroughly after each significant change

## Known Limitations

- Chrome extensions have limited ESM support
- TypeScript path mappings work for development but need bundling for production
- Chrome extensions need careful handling of async operations

## Next Steps

1. Set up a bundler (Webpack or Rollup)
2. Implement the module pattern
3. Migrate code incrementally
4. Add automated testing

================================================
File: /README.md
================================================
# Deep Research Citation Verifier (Athena DeepCite)

A Chrome extension that helps users verify factual claims on webpages and PDFs. 
It combines AI-powered claim detection with Exa's neural search technology to provide source verification and confidence scores for factual statements.

## Features
- Detects factual claims in web pages and PDFs on demand
- Uses AI-powered claim extraction with confidence scoring
- Highlights claims with a subtle blue background
- Shows multiple sources on hover with confidence scores
- Provides direct links to original source documents
- Supports dark mode through CSS variables
- Works with both web pages and PDF documents

## Installation

1. **Clone the repository**
bash
git clone [repository-url]
cd deep-research-citation-verifier

2. **Install dependencies**
bash
npm install

3. **Build the extension**
bash
npm run build


4. **Load in Chrome**
- Open Chrome and go to `chrome://extensions/`
- Enable "Developer mode" in the top right
- Click "Load unpacked"
- Select the extension directory containing `manifest.json`

## Project Structure

```
├── contentScript.ts     # DOM manipulation, highlighting, claim detection
├── background.ts        # API calls, service worker
├── llmExtractor.ts      # AI-powered claim extraction
├── types.ts             # TypeScript interfaces
├── dist/                # Compiled JavaScript
├── lib/                 # Third-party libraries (pdf.js)
├── styles/              # CSS styles with variables
│   └── pdf-overlay.css  # Styling for web and PDF overlays
├── manifest.json        # Extension config and permissions
└── options.html         # Settings page (future development)
```

## Usage

1. **Visit any webpage** with factual content (e.g., news articles, Wikipedia, research blogs)

2. **Click the "Analyze Webpage" button** (top-right) to detect and highlight claims.

3. **The extension will:**
   - Find factual claims in the text using either AI or rule-based analysis
   - Highlight them with a subtle blue background
   - Connect to Exa's API to verify sources

4. **Interact with highlights:**
   - Hover over any highlighted text
   - See source information and confidence scores in a tooltip
   - Click "View source" to open the original reference

## Current Limitations
- Uses developer API key (not for production)
- May highlight only partial paragraphs in some websites
- Requires manual activation via the "Analyze Webpage" button
- Limited to text content (no image analysis)
- Depends on OpenAI API for best results (falls back to rule-based analysis if unavailable)

## Development Notes

### Key Files
- `contentScript.ts`: Handles DOM manipulation, claim detection, and highlighting
- `background.ts`: Manages API calls to Exa for source verification
- `llmExtractor.ts`: Provides AI-powered claim detection with confidence scoring
- `styles/pdf-overlay.css`: Contains all styling with CSS variables for consistent UI
- `manifest.json`: Extension configuration and permissions

### API Keys
The extension relies on two API services that need your own API keys:

1. **Exa API**: Used for retrieving source information for claims
   - You need to add your Exa API key in `background.ts` (replace "EXA-API-KEY-GOES-HERE")
   - Create an account at https://exa.ai to get your API key
   - Will be moved to the options page in a future update

2. **OpenAI API**: Used for improved claim detection and confidence scoring
   - You need to add your OpenAI API key in `background.ts` (replace "OPENAI-API-KEY-GOES-HERE")
   - Create an account at https://platform.openai.com to get your API key
   - The extension will fall back to rule-based detection if the key is invalid
   - Will be configurable in the options page in a future update

**Important:** Never commit API keys to version control. The placeholders in the code must be replaced with real keys locally for testing.

### Building 

bash
npm run build

This compiles TypeScript files to JavaScript in the `dist` directory.

### Reloading
After making changes:
1. Run build command
2. Go to `chrome://extensions/`
3. Click the refresh icon on the extension


### Key Components
- **Claim Detection**: Uses heuristics to find factual statements
- **Source Verification**: Calls Exa API to find supporting sources
- **UI**: Highlights + tooltips showing source info

### Current Limitations
- Uses hardcoded API key (in background.ts)
- Highlights one claim at a time
- Basic error handling
- Text-only analysis

### Making Changes
1. Edit TypeScript files in `src/`
2. Run `npm run build`
3. Refresh extension in Chrome

### Testing on Different Sites
Works best on:
- Wikipedia articles
- News sites
- Research blogs
- Technical documentation

## Next Steps
- [x] Add manual analysis button to respect user privacy
- [x] Support multiple claim highlights
- [x] Improve UI with modern design elements
- [x] Add confidence scores from LLM analysis
- [ ] Refactor code for better maintainability (see docs/IMPLEMENTATION_PLAN.md)
- [ ] Add API key configuration UI in options page
- [ ] Improve cross-site compatibility for highlighting
- [ ] Add error handling for API failures
- [ ] Add browser dark mode support
- [ ] Package for Chrome Web Store

## Development Documentation

For developers working on this extension, please see the following documentation:

- [Current Status](docs/CURRENT_STATUS.md)
- [Testing Guide](docs/TESTING.md)
- [Refactoring Plan](docs/REFACTORING.md)
- [Implementation Plan](docs/IMPLEMENTATION_PLAN.md)


================================================
File: /types.ts
================================================
export interface Claim {
  id: number;
  text: string;
  cleanText?: string;
  context: {
    page: number;
    paragraph: number;
  };
  relevance: number;
  confidence?: number; // Added confidence score from LLM
}

export interface ClaimDetectionResult {
  claims: Claim[];
  totalProcessed: number;
}

export interface ExaSearchResult {
  title: string;
  url: string;
  publishedDate?: string;
  score: number;
  highlights: string[];
}

export interface VerifyClaimRequest {
  type: 'VERIFY_CLAIM';
  claim: Claim;
}

export interface Settings {
  exaKey: string;
  openaiKey: string;
  highlightsEnabled: boolean;
  sidebarEnabled: boolean;
  darkMode: boolean;
  excludedDomains: string[];
  maxVerificationsPerDay: number;
  enableCaching: boolean;
  cacheDuration: number;
  useLLMExtraction: boolean;
  usageCount: number;
  lastUsageReset: number;
}

================================================
File: /styles/pdf-overlay.css
================================================
/* Global variables for consistent styling */
:root {
  /* Primary theme colors - updated for a modern look */
  --primary-color: #2F80ED;
  --primary-hover: #1A73E8;
  --secondary-color: #f8f9fa;
  
  /* Confidence level colors - more vibrant */
  --high-confidence: #34C759;
  --medium-confidence: #FF9500;
  --low-confidence: #FF3B30;
  
  /* Highlight colors - more elegant */
  --highlight-color: rgba(47, 128, 237, 0.15);
  --highlight-hover: rgba(47, 128, 237, 0.25);
  --highlight-border: rgba(47, 128, 237, 0.5);
  
  /* UI colors - refined */
  --tooltip-bg: white;
  --tooltip-border: #e0e0e0;
  --tooltip-shadow: rgba(0, 0, 0, 0.1);
  --text-primary: #333333;
  --text-secondary: #666666;
  --text-muted: #888888;
  --divider-color: #eeeeee;
  
  /* Sources */
  --source-primary: #007AFF;
  --source-bg: rgba(47, 128, 237, 0.05);
  
  /* Animations - smoother */
  --transition-speed: 0.25s;
  
  /* Loading */
  --loading-color: #666666;
  
  /* Unified border radius */
  --border-radius-sm: 6px;
  --border-radius-md: 8px;
  --border-radius-lg: 12px;
  
  /* Font family - system fonts for optimal performance */
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  :root {
    --tooltip-bg: #222222;
    --tooltip-border: #444444;
    --tooltip-shadow: rgba(0, 0, 0, 0.3);
    --text-primary: #f2f2f2;
    --text-secondary: #d0d0d0;
    --text-muted: #a0a0a0;
    --divider-color: #444444;
    --secondary-color: #333333;
    
    /* Adjust colors for dark mode */
    --source-primary: #419CFF;
    --source-bg: rgba(47, 128, 237, 0.15);
    --highlight-color: rgba(47, 128, 237, 0.25);
    --highlight-hover: rgba(47, 128, 237, 0.35);
    
    /* Keep confidence colors vibrant in dark mode */
    --high-confidence: #32D74B;
    --medium-confidence: #FF9F0A;
    --low-confidence: #FF453A;
  }
}

/* Unified Claims Overlay Styles */
.deepcite-claims-overlay {
  position: fixed;
  right: 20px; /* Added margin from edge to avoid collision with site elements */
  top: 20px;
  width: 320px;
  max-height: calc(100vh - 40px); /* Prevent extending beyond viewport */
  background: var(--tooltip-bg);
  box-shadow: 0 6px 24px var(--tooltip-shadow);
  z-index: 9999;
  padding: 20px;
  overflow-y: auto;
  font-family: var(--font-family);
  border: 1px solid var(--tooltip-border);
  border-radius: 12px;
  color: var(--text-primary);
  transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease-in-out, box-shadow 0.3s ease;
  backdrop-filter: blur(5px);
  resize: both; /* Allow user to resize the panel */
  overflow: auto;
  max-width: 90vw; /* Prevent extending beyond viewport width */
  
  /* Add an elegant fade-in animation */
  animation: fadeInOverlay 0.4s cubic-bezier(0.16, 1, 0.3, 1);
}

/* Style for when panel is being dragged */
.deepcite-claims-overlay.dragging {
  opacity: 0.9;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
  transition: none; /* Disable transitions while dragging for better performance */
  user-select: none;
  outline: 2px dashed var(--primary-color);
  outline-offset: 2px;
}

/* Fade-in animation for overlay */
@keyframes fadeInOverlay {
  0% { 
    opacity: 0; 
    transform: translateY(20px) scale(0.97);
  }
  100% { 
    opacity: 1; 
    transform: translateY(0) scale(1);
  }
}

.deepcite-claims-overlay.minimized {
  transform: translateX(calc(100% - 40px));
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
  opacity: 0.9;
  width: 320px; /* Fixed width during animation */
  max-height: 60px;
  overflow: hidden;
  transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.4s ease-in-out, max-height 0.4s ease-in-out, box-shadow 0.4s ease;
}

.deepcite-claims-overlay.minimized:hover {
  opacity: 1;
  transform: translateX(calc(100% - 60px));
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

.deepcite-claims-overlay.minimized::before {
  content: 'DeepCite';
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 14px;
  color: var(--primary-color);
  background: var(--tooltip-bg);
  padding: 4px;
  z-index: 2;
  pointer-events: none;
}

.deepcite-claims-overlay.closed {
  transform: scale(0) translate(100%, -100%);
  visibility: hidden;
  opacity: 0;
  pointer-events: none;
  transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease-in-out, visibility 0s 0.3s;
}

.deepcite-overlay-close {
  position: absolute;
  top: 15px;
  right: 15px;
  width: 24px;
  height: 24px;
  background: var(--secondary-color);
  border: 1px solid var(--divider-color);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  color: var(--text-secondary);
  z-index: 2;
  transition: all var(--transition-speed) ease;
}

.deepcite-claims-overlay.minimized .deepcite-overlay-close {
  right: 5px;
  transform: rotate(180deg);
  background: var(--primary-color);
  color: white;
  border-color: var(--primary-hover);
  box-shadow: -2px 0 8px rgba(0, 0, 0, 0.2);
}

.deepcite-overlay-close:hover {
  background: var(--highlight-hover);
  color: var(--text-primary);
}

.deepcite-claims-header {
  position: sticky;
  top: 0;
  background: var(--tooltip-bg);
  padding: 12px 0 16px 0;
  border-bottom: 2px solid var(--primary-color);
  margin-bottom: 16px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  cursor: move; /* Draggable indicator */
}

.deepcite-claims-header:after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 10px;
  background: linear-gradient(to bottom, var(--tooltip-bg), transparent);
  pointer-events: none;
  opacity: 0.7;
}

.deepcite-claims-header h3 {
  margin: 0 0 6px 0;
  font-size: 18px;
  font-weight: 600;
  color: var(--primary-color);
  display: flex;
  align-items: center;
}

.deepcite-claims-header h3::before {
  content: '';
  display: inline-block;
  width: 18px;
  height: 18px;
  margin-right: 8px;
  background-color: var(--primary-color);
  border-radius: 50%;
  opacity: 0.8;
}

.deepcite-claims-header small {
  color: var(--text-secondary);
  font-size: 13px;
  display: flex;
  align-items: center;
  margin-left: 26px; /* Align with the header text after the dot */
  animation: pulse 2s infinite ease-in-out;
}

@keyframes pulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

/* Legacy PDF Overlay Styles (kept for backward compatibility) */
.pdf-claims-overlay {
  position: fixed;
  right: 0;
  top: 0;
  width: 320px;
  height: 100vh;
  background: var(--tooltip-bg);
  box-shadow: -2px 0 15px var(--tooltip-shadow);
  z-index: 9999;
  padding: 20px;
  overflow-y: auto;
  font-family: var(--font-family);
  border-left: 1px solid var(--tooltip-border);
  color: var(--text-primary);
}

.pdf-claims-header {
  position: sticky;
  top: 0;
  background: var(--tooltip-bg);
  padding: 12px 0;
  border-bottom: 1px solid var(--divider-color);
  margin-bottom: 16px;
}

.pdf-claims-header h3 {
  margin: 0 0 4px 0;
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.pdf-claims-header small {
  color: var(--text-secondary);
  font-size: 13px;
}

.deepcite-claim-item, .pdf-claim-item {
  margin-bottom: 16px;
  padding: 16px;
  border: 1px solid var(--divider-color);
  border-radius: 10px;
  transition: all 0.2s ease;
  cursor: pointer;
  background-color: var(--secondary-color);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  position: relative;
  overflow: hidden;
  animation: claimItemFadeIn 0.5s cubic-bezier(0.16, 1, 0.3, 1) backwards;
}

/* Staggered animation for claim items */
@keyframes claimItemFadeIn {
  0% {
    opacity: 0;
    transform: translateY(15px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Apply staggered delay to items */
.deepcite-claim-item:nth-child(1), .pdf-claim-item:nth-child(1) { animation-delay: 0.1s; }
.deepcite-claim-item:nth-child(2), .pdf-claim-item:nth-child(2) { animation-delay: 0.15s; }
.deepcite-claim-item:nth-child(3), .pdf-claim-item:nth-child(3) { animation-delay: 0.2s; }
.deepcite-claim-item:nth-child(4), .pdf-claim-item:nth-child(4) { animation-delay: 0.25s; }
.deepcite-claim-item:nth-child(5), .pdf-claim-item:nth-child(5) { animation-delay: 0.3s; }
.deepcite-claim-item:nth-child(n+6), .pdf-claim-item:nth-child(n+6) { animation-delay: 0.35s; }

.deepcite-claim-item:hover, .pdf-claim-item:hover {
  transform: translateY(-3px);
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.08);
  border-color: var(--primary-color);
}

.deepcite-claim-item::before, .pdf-claim-item::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  width: 4px;
  background: linear-gradient(to bottom, var(--primary-color), var(--primary-hover));
  opacity: 0;
  transition: opacity 0.2s ease;
}

.deepcite-claim-item:hover::before, .pdf-claim-item:hover::before {
  opacity: 1;
}

.deepcite-claim-text {
  margin-bottom: 8px;
  line-height: 1.4;
}

.deepcite-claim-confidence {
  margin-top: 6px;
  margin-bottom: 8px;
  font-size: 13px;
  padding: 6px;
  background: var(--source-bg);
  border-radius: 6px;
}

.deepcite-claim-sources {
  margin-top: 10px;
  background: var(--source-bg);
  padding: 10px;
  border-radius: 6px;
}

.deepcite-claim-sources-header {
  font-weight: 600;
  margin-bottom: 8px;
  font-size: 14px;
}

.deepcite-claim-source-item {
  margin-bottom: 8px;
}

.deepcite-source-title a {
  color: var(--source-primary);
  text-decoration: none;
}

.deepcite-source-title a:hover {
  text-decoration: underline;
}

.deepcite-source-confidence {
  margin-left: 6px;
  font-size: 12px;
  background: var(--source-bg);
  padding: 2px 6px;
  border-radius: 4px;
  color: var(--text-secondary);
}

.deepcite-source-divider {
  margin: 10px 0;
  border: 0;
  border-top: 1px solid var(--divider-color);
}

.pdf-claim-location {
  font-size: 12px;
  color: var(--text-secondary);
  margin-bottom: 6px;
  display: inline-block;
  background: var(--source-bg);
  padding: 2px 6px;
  border-radius: 4px;
}

.pdf-claim-confidence {
  margin-top: 6px;
  margin-bottom: 8px;
  font-size: 13px;
}

.pdf-claim-sources {
  margin-top: 10px;
  background: var(--source-bg);
  padding: 10px;
  border-radius: 6px;
}

.pdf-claim-sources-header {
  font-weight: 600;
  margin-bottom: 8px;
  font-size: 14px;
  color: var(--text-primary);
}

.pdf-claim-source-item {
  margin-bottom: 8px;
  transition: all var(--transition-speed) ease;
}

.pdf-claim-source-item:hover {
  transform: translateX(2px);
}

.pdf-source-title {
  font-weight: 500;
  margin-bottom: 4px;
}

.pdf-source-title a {
  color: var(--source-primary);
  text-decoration: none;
  transition: color var(--transition-speed) ease;
}

.pdf-source-title a:hover {
  text-decoration: underline;
}

.pdf-source-confidence {
  margin-left: 6px;
  font-size: 12px;
  background: var(--source-bg);
  padding: 2px 6px;
  border-radius: 4px;
  color: var(--text-secondary);
}

.pdf-source-divider {
  margin: 10px 0;
  border: 0;
  border-top: 1px solid var(--divider-color);
}

/* Buttons */
.analyze-pdf-button, .analyze-webpage-button {
  position: fixed;
  right: 20px;
  padding: 12px 20px;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--border-radius-md);
  cursor: pointer;
  z-index: 10000;
  font-family: var(--font-family);
  font-size: 14px;
  font-weight: var(--font-weight-medium);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  transition: all var(--transition-speed) cubic-bezier(0.16, 1, 0.3, 1);
  letter-spacing: 0.2px;
  animation: buttonFadeIn 0.5s cubic-bezier(0.16, 1, 0.3, 1) backwards;
  display: flex;
  align-items: center;
  justify-content: center;
}

@keyframes buttonFadeIn {
  0% {
    opacity: 0;
    transform: scale(0.9) translateY(10px);
  }
  100% {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.analyze-pdf-button {
  top: 20px;
  animation-delay: 0.1s;
}

.analyze-pdf-button::before {
  content: '📄';
  margin-right: 8px;
  font-size: 16px;
}

.analyze-webpage-button {
  top: 80px;
  animation-delay: 0.2s;
}

.analyze-webpage-button::before {
  content: '🔍';
  margin-right: 8px;
  font-size: 16px;
}

.analyze-pdf-button:hover, .analyze-webpage-button:hover {
  background: var(--primary-hover);
  transform: translateY(-3px) scale(1.03);
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
}

.analyze-pdf-button:active, .analyze-webpage-button:active {
  transform: translateY(1px) scale(0.98);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
}

.analyze-pdf-button:disabled, .analyze-webpage-button:disabled {
  opacity: 0.7;
  cursor: not-allowed;
  transform: none;
  animation: processingPulse 1.5s infinite ease-in-out;
}

@keyframes processingPulse {
  0%, 100% { background-color: var(--primary-color); }
  50% { background-color: var(--primary-hover); }
}

/* Web Highlights and Tooltips */
.exa-claim-highlight {
  background-color: var(--highlight-color) !important;
  border-bottom: 2px solid var(--highlight-border) !important;
  cursor: pointer !important;
  display: inline !important;
  padding: 2px 0 !important;
  position: relative !important;
  transition: all 0.2s ease !important;
  border-radius: 4px !important;
  text-decoration: none !important;
}

.exa-claim-highlight:hover {
  background-color: var(--highlight-hover) !important;
  transform: translateY(-1px) !important;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1) !important;
}

.exa-tooltip {
  position: fixed !important;
  background: var(--tooltip-bg) !important;
  border: 1px solid var(--tooltip-border) !important;
  box-shadow: 0 8px 24px var(--tooltip-shadow) !important;
  padding: 14px 18px !important;
  border-radius: var(--border-radius-md) !important;
  font-size: 14px !important;
  max-width: 320px !important;
  z-index: 999999 !important;
  color: var(--text-primary) !important;
  backdrop-filter: blur(10px) !important;
  transform: translateY(8px) !important;
  opacity: 0 !important;
  transition: opacity var(--transition-speed), transform var(--transition-speed) cubic-bezier(0.16, 1, 0.3, 1) !important;
  font-family: var(--font-family) !important;
  line-height: 1.5 !important;
}

.exa-tooltip.visible {
  opacity: 1 !important;
  transform: translateY(0) !important;
  animation: tooltipAppear 0.25s cubic-bezier(0.16, 1, 0.3, 1) !important;
}

@keyframes tooltipAppear {
  0% { transform: translateY(8px) scale(0.95); opacity: 0; }
  100% { transform: translateY(0) scale(1); opacity: 1; }
}

.exa-tooltip::before {
  content: '' !important;
  position: absolute !important;
  top: -6px !important;
  left: 20px !important;
  width: 12px !important;
  height: 12px !important;
  background: var(--tooltip-bg) !important;
  border-left: 1px solid var(--tooltip-border) !important;
  border-top: 1px solid var(--tooltip-border) !important;
  transform: rotate(45deg) !important;
}

.exa-tooltip a {
  color: var(--source-primary) !important;
  text-decoration: none !important;
  cursor: pointer !important;
  transition: all var(--transition-speed) ease !important;
}

.exa-tooltip a:hover {
  text-decoration: underline !important;
}

.exa-tooltip-header {
  display: flex !important;
  align-items: center !important;
  margin-bottom: 8px !important;
}

.exa-tooltip-favicon {
  width: 16px !important;
  height: 16px !important;
  margin-right: 8px !important;
  border-radius: 2px !important;
}

.exa-tooltip-source {
  margin-bottom: 10px !important;
  padding: 6px !important;
  border-radius: 6px !important;
  transition: background 0.2s !important;
}

.exa-tooltip-source:hover {
  background: var(--source-bg) !important;
}

.exa-tooltip-source-header {
  display: flex !important;
  align-items: center !important;
  margin-bottom: 6px !important;
}

.exa-sources-header {
  font-weight: 600 !important;
  margin-bottom: 10px !important;
  color: var(--text-primary) !important;
}

.exa-claim-confidence {
  margin-bottom: 10px !important;
  padding: 6px 8px !important;
  background: var(--source-bg) !important;
  border-radius: 6px !important;
  font-size: 13px !important;
}

.exa-tooltip-nav {
  display: flex !important;
  align-items: center !important;
  justify-content: space-between !important;
  margin-top: 10px !important;
  padding-top: 8px !important;
  border-top: 1px solid var(--divider-color) !important;
}

.exa-tooltip-nav button {
  background: var(--secondary-color) !important;
  border: 1px solid var(--divider-color) !important;
  color: var(--text-primary) !important;
  cursor: pointer !important;
  padding: 4px 10px !important;
  border-radius: 6px !important;
  transition: all var(--transition-speed) ease !important;
  font-family: var(--font-family) !important;
}

.exa-tooltip-nav button:hover:not(:disabled) {
  background: var(--highlight-color) !important;
  border-color: var(--primary-color) !important;
}

.exa-tooltip-nav button:disabled {
  opacity: 0.5 !important;
  cursor: not-allowed !important;
}

.exa-source-confidence {
  display: inline-block !important;
  padding: 2px 6px !important;
  background: var(--source-bg) !important;
  border-radius: 4px !important;
  font-size: 12px !important;
  margin-left: 8px !important;
  color: var(--text-secondary) !important;
}

/* Confidence meter styling */
.confidence-meter {
  display: inline-block !important;
  height: 8px !important;
  border-radius: 4px !important;
  margin: 0 6px !important;
  vertical-align: middle !important;
  min-width: 20px !important;
  max-width: 100px !important;
  transition: width 0.3s ease-in-out !important;
}

.confidence-text {
  font-weight: 500 !important;
  margin-left: 4px !important;
  vertical-align: middle !important;
}

/* Animation for highlight flash - enhanced for better visibility */
@keyframes highlightFlash {
  0% { 
    background-color: var(--highlight-color);
    box-shadow: 0 0 0 rgba(47, 128, 237, 0);
  }
  15% { 
    background-color: var(--primary-color);
    color: white; 
    box-shadow: 0 0 20px rgba(47, 128, 237, 0.8);
    transform: scale(1.04);
    border-radius: 5px;
  }
  40% { 
    background-color: var(--primary-color);
    color: white;
    box-shadow: 0 0 12px rgba(47, 128, 237, 0.5);
    transform: scale(1.02);
    border-radius: 5px;
  }
  70% {
    background-color: var(--highlight-hover);
    box-shadow: 0 0 5px rgba(47, 128, 237, 0.2);
    transform: scale(1.01);
  }
  100% { 
    background-color: var(--highlight-color);
    box-shadow: 0 0 0 rgba(47, 128, 237, 0);
    transform: scale(1);
  }
}

.exa-claim-highlight-flash {
  animation: highlightFlash 2s cubic-bezier(0.16, 1, 0.3, 1);
  z-index: 1000 !important; /* Make sure flashing highlight is visible */
}

/* Animation for loading spinner */
@keyframes spin {
  to { transform: rotate(360deg); }
}

.exa-loading {
  display: inline-block !important;
  width: 16px !important;
  height: 16px !important;
  border: 2px solid var(--loading-color) !important;
  border-top-color: transparent !important;
  border-radius: 50% !important;
  animation: spin 1s linear infinite !important;
}

/* Close panel button styling */
.deepcite-close-panel-button {
  display: block;
  margin: 20px auto 10px auto;
  padding: 10px 18px;
  background-color: var(--secondary-color);
  color: var(--text-primary);
  border: 1px solid var(--divider-color);
  border-radius: 6px;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: 14px;
  font-weight: var(--font-weight-medium);
  transition: all 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  text-align: center;
}

.deepcite-close-panel-button:hover {
  background-color: var(--highlight-color);
  border-color: var(--primary-color);
  color: var(--primary-color);
  transform: translateY(-1px);
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
}

/* Verify button styling */
.verify-claim-btn {
  display: inline-block;
  margin: 10px 0;
  padding: 8px 16px;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--border-radius-md);
  cursor: pointer;
  font-family: var(--font-family);
  font-size: 14px;
  font-weight: var(--font-weight-medium);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
  outline: none;
}

.verify-claim-btn:hover {
  background: var(--primary-hover);
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.verify-claim-btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.verify-claim-btn:disabled {
  background: var(--primary-color);
  opacity: 0.7;
  cursor: wait;
  transform: none;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
}

/* Styling for DeepCite badge */
.deepcite-badge {
  display: inline-block !important;
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%) !important;
  color: white !important;
  padding: 3px 8px !important;
  border-radius: 4px !important;
  font-size: 14px !important;
  font-weight: bold !important;
  margin-left: 8px !important;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2) !important;
  letter-spacing: 0.5px !important;
  position: relative !important;
  z-index: 99999 !important; /* Make sure badge is always on top */
  user-select: none !important;
  cursor: pointer !important;
  transition: all 0.2s ease !important;
  font-family: var(--font-family) !important;
}

.deepcite-badge:hover {
  background: linear-gradient(135deg, var(--primary-hover) 0%, var(--primary-color) 100%) !important;
  transform: translateY(-1px) !important;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3) !important;
}

================================================
File: /background.ts
================================================
// Define types inline since we can't use modules in service worker
interface ExaSearchResult {
  title: string;
  url: string;
  publishedDate?: string;
  score: number;
  highlights: string[];
}

interface VerifyClaimRequest {
  type: 'VERIFY_CLAIM';
  claim: {
    id: number;
    text: string;
    context: {
      page: number;
      paragraph: number;
    };
    relevance: number;
  };
}

interface Settings {
  exaKey: string;
  openaiKey: string;
  highlightsEnabled: boolean;
  sidebarEnabled: boolean;
  darkMode: boolean;
  excludedDomains: string[];
  maxVerificationsPerDay: number;
  enableCaching: boolean;
  cacheDuration: number;
  useLLMExtraction: boolean;
  usageCount: number;
  lastUsageReset: number;
}

interface ClaimCache {
  timestamp: number;
  results: ExaSearchResult[];
}

// Ensure service worker activates
console.log('Background service worker starting...');

// Basic background service worker
chrome.runtime.onInstalled.addListener(() => {
  console.log('Extension installed');
  // Set default settings if not already set
  chrome.storage.local.get([
    'openaiKey', 
    'exaKey', 
    'maxVerificationsPerDay',
    'enableCaching',
    'cacheDuration',
    'usageCount',
    'lastUsageReset'
  ], (result) => {
    const defaults: any = {};
    
    if (!result.openaiKey) {
      defaults['openaiKey'] = '';
    }
    
    if (!result.exaKey) {
      defaults['exaKey'] = '';
    }
    
    if (result.maxVerificationsPerDay === undefined) {
      defaults['maxVerificationsPerDay'] = 10;
    }
    
    if (result.enableCaching === undefined) {
      defaults['enableCaching'] = true;
    }
    
    if (result.cacheDuration === undefined) {
      defaults['cacheDuration'] = 7;
    }
    
    if (result.usageCount === undefined) {
      defaults['usageCount'] = 0;
    }
    
    if (result.lastUsageReset === undefined) {
      defaults['lastUsageReset'] = Date.now();
    }
    
    if (Object.keys(defaults).length > 0) {
      chrome.storage.local.set(defaults);
    }
  });
});

// Check if usage limits should be reset (new day)
async function checkAndResetDailyUsage(): Promise<void> {
  const { lastUsageReset } = await chrome.storage.local.get(['lastUsageReset']);
  
  if (lastUsageReset) {
    const lastResetDate = new Date(lastUsageReset).toDateString();
    const todayDate = new Date().toDateString();
    
    if (lastResetDate !== todayDate) {
      // It's a new day, reset the counter
      console.log('New day detected, resetting usage counter');
      await chrome.storage.local.set({
        usageCount: 0,
        lastUsageReset: Date.now()
      });
    }
  }
}

// The Exa API key will be retrieved from storage in the verifyClaimWithExa function
const EXA_API_URL = 'https://api.exa.ai/search';

/**
 * Verify a claim using Exa's API to find supporting sources
 * This is the core function that connects claims to reliable sources
 * 
 * @param claim - The text of the claim to verify
 * @returns Promise resolving to an array of search results with source information
 */
async function verifyClaimWithExa(claim: string): Promise<ExaSearchResult[]> {
  try {
    // First check for a new day to potentially reset usage counter
    await checkAndResetDailyUsage();

    // Get settings from storage
    const settings = await chrome.storage.local.get([
      'exaKey', 
      'maxVerificationsPerDay', 
      'enableCaching', 
      'cacheDuration',
      'usageCount'
    ]) as Settings;
    
    const { 
      exaKey, 
      maxVerificationsPerDay = 10, 
      enableCaching = true, 
      cacheDuration = 7,
      usageCount = 0 
    } = settings;
    
    if (!exaKey) {
      throw new Error('Exa API key not found. Please set it in the extension options.');
    }
    
    // Check if user has reached daily limit
    if (maxVerificationsPerDay > 0 && usageCount >= maxVerificationsPerDay) {
      throw new Error(`Daily verification limit (${maxVerificationsPerDay}) reached. Please try again tomorrow.`);
    }
    
    // Check cache first if enabled
    if (enableCaching) {
      const cacheKey = `cache:${claim}`;
      const cachedData = await chrome.storage.local.get([cacheKey]);
      
      if (cachedData && cachedData[cacheKey]) {
        const cache = cachedData[cacheKey] as ClaimCache;
        
        // Check if cache is still valid based on cacheDuration (days)
        const cacheAgeMs = Date.now() - cache.timestamp;
        const cacheMaxAgeMs = cacheDuration * 24 * 60 * 60 * 1000; // Convert days to ms
        
        if (cacheAgeMs < cacheMaxAgeMs) {
          console.log('Returning cached result for claim');
          return cache.results;
        } else {
          console.log('Cache expired, fetching fresh results');
        }
      }
    }
    
    // Send the claim to Exa API as a neural search query
    // This uses semantic understanding rather than just keyword matching
    const response = await fetch(EXA_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${exaKey}`
      },
      body: JSON.stringify({
        query: claim,
        numResults: 3, // Limit to 3 sources for UI simplicity
        type: 'neural'  // Use neural search for better semantic understanding
      })
    });

    if (!response.ok) {
      throw new Error(`Exa API error: ${response.status}`);
    }

    const data = await response.json();
    const results = data.results;
    
    // Update usage counter
    await chrome.storage.local.set({ usageCount: usageCount + 1 });
    
    // Cache the results if caching is enabled
    if (enableCaching) {
      const cacheKey = `cache:${claim}`;
      const cacheData: ClaimCache = {
        timestamp: Date.now(),
        results: results
      };
      
      await chrome.storage.local.set({ [cacheKey]: cacheData });
    }
    
    return results;
  } catch (error) {
    console.error('Error verifying claim:', error);
    throw error;
  }
}

// Listen for messages from content script
// This handles the communication between the content script (UI) and background service worker (API calls)
chrome.runtime.onMessage.addListener((
  request: VerifyClaimRequest,
  sender: chrome.runtime.MessageSender,
  sendResponse: (response?: any) => void
) => {
  if (request.type === 'VERIFY_CLAIM') {
    // Process the claim verification request
    // This keeps API calls in the background script for better security and performance
    verifyClaimWithExa(request.claim.text)
      .then(results => {
        console.log('Verification results:', results);
        sendResponse({ success: true, results });
      })
      .catch(error => {
        // Check if this is a daily limit error
        if (error.message && error.message.includes('Daily verification limit')) {
          console.warn('Daily limit reached:', error.message);
          sendResponse({ 
            success: false, 
            error: 'DAILY_LIMIT_REACHED',
            message: error.message,
            results: [] 
          });
        } else {
          // Handle other API errors gracefully by returning an empty results array
          console.error('Verification failed:', error);
          sendResponse({ success: false, error: 'API_ERROR', results: [] });
        }
      });
    return true; // Return true to indicate we'll respond asynchronously
  } else if (request.type === 'GET_USAGE_STATS') {
    // Return current usage statistics
    chrome.storage.local.get(['usageCount', 'maxVerificationsPerDay', 'lastUsageReset'], (result) => {
      sendResponse({
        success: true,
        usageCount: result.usageCount || 0,
        maxVerificationsPerDay: result.maxVerificationsPerDay || 10,
        lastUsageReset: result.lastUsageReset || Date.now()
      });
    });
    return true;
  }
  return true; // Always return true from the listener
});

// Clean up old cached items periodically
async function cleanupOldCaches(): Promise<void> {
  try {
    // Get all storage items
    const allItems = await chrome.storage.local.get(null);
    const { cacheDuration = 7 } = allItems;
    
    // Find all cache keys
    const cacheKeys = Object.keys(allItems).filter(key => key.startsWith('cache:'));
    const keysToRemove: string[] = [];
    
    // Check each cache's age
    const now = Date.now();
    const maxAgeMs = cacheDuration * 24 * 60 * 60 * 1000; // Convert days to ms
    
    for (const key of cacheKeys) {
      const cache = allItems[key] as ClaimCache;
      if (cache && cache.timestamp) {
        const age = now - cache.timestamp;
        if (age > maxAgeMs) {
          keysToRemove.push(key);
        }
      }
    }
    
    // Remove old caches
    if (keysToRemove.length > 0) {
      console.log(`Removing ${keysToRemove.length} expired cache entries`);
      await chrome.storage.local.remove(keysToRemove);
    }
  } catch (error) {
    console.error('Error cleaning up caches:', error);
  }
}

// Run cache cleanup once a day
setInterval(cleanupOldCaches, 24 * 60 * 60 * 1000); // Every 24 hours

// Also run cleanup when extension starts
cleanupOldCaches();

================================================
File: /package.json
================================================
{
  "scripts": {
    "build": "tsc",
    "lint": "eslint ."
  },
  "name": "athena-deepcite",
  "version": "1.0.0",
  "main": "index.js",
  "keywords": [
    "chrome-extension",
    "fact-checking",
    "citation",
    "research"
  ],
  "author": "",
  "license": "ISC",
  "description": "A Chrome extension for verifying factual claims with source citations",
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@types/chrome": "^0.0.304",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.27.0"
  }
}


================================================
File: /manifest.json
================================================
{
  "manifest_version": 3,
  "name": "Deep Research Citation Verifier",
  "version": "1.0.0",
  "description": "Verifies factual claims in documents using Exa's API and overlays citations",
  "permissions": [
    "storage",
    "activeTab",
    "webRequest"
  ],
  "host_permissions": [
    "https://api.exa.ai/*",
    "https://api.openai.com/*",
    "<all_urls>"
  ],
  "web_accessible_resources": [{
    "resources": ["pdf.worker.min.js", "styles/pdf-overlay.css"],
    "matches": ["<all_urls>"]
  }],
  "background": {
    "service_worker": "dist/background.js"
  },
  "content_scripts": [
    {
      "matches": [
        "<all_urls>",
        "file://*/*.pdf",
        "https://*/*.pdf"
      ],
      "js": [
        "lib/pdf.min.js",
        "dist/llmExtractor.js",
        "dist/contentScript.js"
      ],
      "css": ["styles/pdf-overlay.css"]
    }
  ],
  "action": {
    "default_popup": "popup.html"
  },
  "options_page": "options.html"
} 

================================================
File: /tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist",
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "@handlers/*": ["src/handlers/*"],
      "@extractors/*": ["src/extractors/*"],
      "@utils/*": ["src/utils/*"],
      "@types": ["src/types"]
    },
    // Commented out rootDir to allow files in their original locations
    // "rootDir": "src"
  },
  "include": ["./**/*.ts"],
  "exclude": ["node_modules"]
}

================================================
File: /options.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Deep Research Citation Verifier Settings</title>
  <style>
    body {
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      color: #333;
    }

    .section {
      margin-bottom: 30px;
      padding: 20px;
      border: 1px solid #eee;
      border-radius: 8px;
    }

    h2 {
      margin-top: 0;
      color: #0066cc;
    }

    .field {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }

    input[type="text"], textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: inherit;
    }

    .api-key-container {
      display: flex;
      gap: 10px;
    }

    .api-key-container input {
      flex: 1;
    }

    button {
      padding: 8px 16px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background: #0052a3;
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .toggle-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toggle {
      position: relative;
      width: 50px;
      height: 24px;
    }

    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #0066cc;
    }

    input:checked + .slider:before {
      transform: translateX(26px);
    }

    .status {
      margin-left: 10px;
      font-size: 14px;
    }

    .success { color: #28a745; }
    .error { color: #dc3545; }
  </style>
</head>
<body>
  <div class="section">
    <h2>API Keys</h2>
    <div class="field">
      <label for="exaKey">Exa API Key (Required)</label>
      <div class="api-key-container">
        <input type="text" id="exaKey" placeholder="Enter your Exa API key">
        <button id="testExaKey">Test Key</button>
      </div>
      <span id="exaKeyStatus" class="status"></span>
    </div>
    <div class="field">
      <label for="openaiKey">OpenAI API Key (Optional - Enables advanced features)</label>
      <div class="api-key-container">
        <input type="text" id="openaiKey" placeholder="Enter your OpenAI API key">
        <button id="testOpenAIKey">Test Key</button>
      </div>
      <span id="openaiKeyStatus" class="status"></span>
      <p style="color: #dc3545; font-weight: bold; margin-top: 5px;">
        IMPORTANT: After entering or changing API keys, click "Save Settings" below!
      </p>
    </div>
  </div>

  <div class="section">
    <h2>Extraction & Appearance</h2>
    <div class="field toggle-container">
      <label class="toggle">
        <input type="checkbox" id="useLLMExtraction">
        <span class="slider"></span>
      </label>
      <span>Use AI-powered extraction (requires OpenAI key)</span>
      <span style="display: block; margin-left: 60px; font-size: 13px; color: #666;">
        When enabled, uses AI to identify factual claims. When disabled, uses rule-based extraction.
      </span>
    </div>
    <div class="field toggle-container">
      <label class="toggle">
        <input type="checkbox" id="highlightsEnabled">
        <span class="slider"></span>
      </label>
      <span>Enable claim highlights</span>
    </div>
    <div class="field toggle-container">
      <label class="toggle">
        <input type="checkbox" id="sidebarEnabled">
        <span class="slider"></span>
      </label>
      <span>Show sidebar automatically</span>
    </div>
    <div class="field toggle-container">
      <label class="toggle">
        <input type="checkbox" id="darkMode">
        <span class="slider"></span>
      </label>
      <span>Use dark mode for tooltips</span>
    </div>
  </div>

  <div class="section">
    <h2>Usage Management</h2>
    <div class="field">
      <label for="maxVerifications">Maximum API Verification Calls Per Day (0 = unlimited)</label>
      <input type="number" id="maxVerifications" min="0" max="1000" placeholder="10" style="width: 100px;">
      <div style="margin-top: 5px; color: #666; font-size: 14px;">
        <span>Current usage today: </span>
        <span id="currentUsage">0</span> calls
        <button id="resetUsage" style="margin-left: 10px; background-color: #f8f9fa; color: #333; border: 1px solid #ddd;">Reset Counter</button>
      </div>
    </div>
    <div class="field toggle-container">
      <label class="toggle">
        <input type="checkbox" id="enableCaching">
        <span class="slider"></span>
      </label>
      <span>Enable Claim Caching (save API costs)</span>
    </div>
    <div class="field">
      <label for="cacheDuration">Cache Duration (in days)</label>
      <input type="number" id="cacheDuration" min="1" max="30" placeholder="7" style="width: 100px;">
    </div>
  </div>

  <div class="section">
    <h2>Site Settings</h2>
    <div class="field">
      <label for="excludedDomains">Excluded Domains (one per line)</label>
      <textarea id="excludedDomains" rows="5" placeholder="example.com&#10;internal.company.com"></textarea>
    </div>
  </div>

  <button id="saveSettings" style="padding: 10px 20px; font-size: 16px; font-weight: bold; background-color: #34C759;">Save Settings</button>
<span id="saveStatus" class="status" style="font-size: 16px;"></span>
</body>
<script src="dist/options.js"></script>
</html> 

================================================
File: /eslint.config.js
================================================
import eslint from '@eslint/js';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  eslint.configs.recommended,
  ...tseslint.configs.recommended,
  {
    languageOptions: {
      globals: {
        chrome: true,
        document: true,
        window: true,
      },
    },
    rules: {
      'indent': ['error', 2],
      'linebreak-style': ['error', 'unix'],
      'quotes': ['error', 'single', { 'allowTemplateLiterals': true }],
      'semi': ['error', 'always'],
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
    },
  },
);

================================================
File: /llmExtractor.js
================================================
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * Extracts factual claims from text using OpenAI's GPT-4
 * This provides more accurate claim detection than rule-based approaches
 * and includes confidence scoring for each claim
 */
// Make the class global for content script access
var LLMExtractor = /** @class */ (function () {
    /**
     * Initialize the extractor with an OpenAI API key
     * @param apiKey - OpenAI API key
     */
    function class_1(apiKey) {
        this.maxTokens = 4000; // GPT-4 context window limit
        this.apiKey = apiKey;
    }
    class_1.prototype.extractClaimsFromChunk = function (text) {
        return __awaiter(this, void 0, void 0, function () {
            var response, data, claims, parsed, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, fetch('https://api.openai.com/v1/chat/completions', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': "Bearer ".concat(this.apiKey)
                                },
                                body: JSON.stringify({
                                    model: 'gpt-4',
                                    messages: [{
                                            role: 'system',
                                            content: "Extract factual claims from the text. Return a JSON array where each item has:\n              - claim: The exact claim text\n              - confidence: 0-1 score of how clearly it's a factual claim\n              Only include clear, verifiable claims. Ignore opinions and subjective statements.\n              Only include statements that appear to assert a verifiable fact. Exclude anything that is speculative or an opinion."
                                        }, {
                                            role: 'user',
                                            content: text
                                        }],
                                    temperature: 0.1
                                })
                            })];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) {
                            throw new Error("OpenAI API error: ".concat(response.status));
                        }
                        return [4 /*yield*/, response.json()];
                    case 2:
                        data = _a.sent();
                        claims = data.choices[0].message.content;
                        parsed = JSON.parse(claims);
                        return [2 /*return*/, {
                                claims: parsed.map(function (p) { return p.claim; }),
                                confidence: parsed.map(function (p) { return p.confidence; })
                            }];
                    case 3:
                        error_1 = _a.sent();
                        console.error('LLM extraction failed:', error_1);
                        return [2 /*return*/, { claims: [], confidence: [] }];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    class_1.prototype.chunkText = function (text, maxLength) {
        if (maxLength === void 0) { maxLength = 3000; }
        // Split into paragraphs
        var paragraphs = text.split(/\n\s*\n/);
        var chunks = [];
        var currentChunk = '';
        for (var _i = 0, paragraphs_1 = paragraphs; _i < paragraphs_1.length; _i++) {
            var paragraph = paragraphs_1[_i];
            if ((currentChunk + paragraph).length > maxLength) {
                if (currentChunk)
                    chunks.push(currentChunk);
                currentChunk = paragraph;
            }
            else {
                currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
            }
        }
        if (currentChunk)
            chunks.push(currentChunk);
        return chunks;
    };
    /**
     * Extract factual claims from text with confidence scores
     * Handles large texts by chunking and processing in parallel
     *
     * @param text - The text to analyze for factual claims
     * @returns Promise resolving to claims and confidence scores
     */
    class_1.prototype.extractClaims = function (text) {
        return __awaiter(this, void 0, void 0, function () {
            var chunks, results;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        chunks = this.chunkText(text);
                        return [4 /*yield*/, Promise.all(chunks.map(function (chunk) { return _this.extractClaimsFromChunk(chunk); }))];
                    case 1:
                        results = _a.sent();
                        // Merge results from all chunks into a single result
                        return [2 /*return*/, {
                                claims: results.flatMap(function (r) { return r.claims; }),
                                confidence: results.flatMap(function (r) { return r.confidence; })
                            }];
                }
            });
        });
    };
    return class_1;
}());


================================================
File: /CLAUDE.md
================================================
# Athena DeepCite Development Guide

## Build & Development Commands
- Build: `npm run build` (compiles TS to JS in dist/)
- Lint: `npm run lint` (runs ESLint checks)
- Test extension: Navigate to test webpage and click "Analyze Webpage" button
- Test PDFs: Open PDF in Chrome and click "Analyze PDF" button
- Load extension: Use `chrome://extensions/` → dev mode → "Load unpacked"
- Debug: Console logs (filter by "DeepCite" in background/content scripts)
- Troubleshoot: Check `chrome://extensions/` → "Errors" if extension fails

## Code Style Guidelines
- TypeScript with strict typing (`strict: true` in tsconfig.json)
- Imports: built-ins → libraries → local modules
- Format: 2-space indent, Unix endings, single quotes, camelCase variables, PascalCase types
- API keys: Store in extension options, never hardcode in source
- Error handling: Always wrap API calls in try/catch with detailed logging
- Async: Use async/await pattern with proper error handling
- Module pattern: Use namespaces for modularity (see REFACTORING.md)
- Message passing: Use typed messages between scripts (`{ type: 'ACTION_TYPE', payload }`)
- Modern JS: ES2020+ syntax, functional style, arrow functions
- Performance: Batch async calls, debounce UI updates, use caching

## Extension Architecture
- contentScript.ts: DOM interactions, UI overlays, claim highlighting
- background.ts: API calls, message handling, source verification
- llmExtractor.ts: AI-powered claim detection and confidence scoring
- types.ts: Shared interfaces for data structures
- PDF handling: Special UI via pdf.js for document analysis

## Security Notes
- Never expose API keys in content scripts; store in background scripts only
- Sanitize any dynamic DOM insertion to prevent XSS
- Follow Chrome Manifest V3 rules for extension security

================================================
File: /contentScript.js
================================================
"use strict";
class PDFHandler {
    constructor(url) {
        this.pdfDoc = null;
        this.textItems = [];
        this.url = url;
        // @ts-ignore
        pdfjsLib.GlobalWorkerOptions.workerSrc = chrome.runtime.getURL('pdf.worker.min.js');
    }
    async init() {
        try {
            // @ts-ignore
            const loadingTask = pdfjsLib.getDocument(this.url);
            this.pdfDoc = await loadingTask.promise;
        }
        catch (error) {
            console.error('Error loading PDF:', error);
            throw error;
        }
    }
    async getPageContent(pageNum) {
        const page = await this.pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: 1.0 });
        const textContent = await page.getTextContent();
        let currentParagraph = 0;
        let lastY;
        textContent.items.forEach((item) => {
            if (lastY !== undefined && Math.abs(item.transform[5] - lastY) > 15) {
                currentParagraph++;
            }
            lastY = item.transform[5];
            this.textItems.push({
                str: item.str,
                pageNum,
                paragraph: currentParagraph
            });
        });
        const text = textContent.items.map((item) => item.str).join(' ');
        return { text, viewport, pageNum };
    }
    async getAllContent() {
        const numPages = this.pdfDoc.numPages;
        const pageTexts = [];
        for (let i = 1; i <= numPages; i++) {
            const { text } = await this.getPageContent(i);
            pageTexts.push(text);
        }
        return pageTexts.join('\n\n');
    }
    findTextLocation(text) {
        for (let i = 0; i < this.textItems.length; i++) {
            const windowSize = 100;
            const chunk = this.textItems.slice(i, i + windowSize)
                .map(item => item.str)
                .join(' ');
            if (chunk.includes(text)) {
                return this.textItems[i];
            }
        }
        return null;
    }
}
/**
 * Extracts and processes factual claims from webpage content
 * This class uses rule-based heuristics to identify claims
 * It serves as a fallback when LLM-based extraction is unavailable
 */
class ContentExtractor {
    constructor() {
        this.claimCounter = 0;
    }
    /**
     * Get main content from webpage, excluding navigation, footers, etc.
     * Focuses on paragraphs with substantive content by filtering out
     * short text elements that are likely UI components
     */
    getMainContent() {
        console.log('Getting main content from webpage');
        // Get all text-containing elements
        const allElements = document.body.querySelectorAll('p, h1, h2, h3, h4, h5, h6, article, section, div');
        console.log(`Found ${allElements.length} potential text elements`);
        // Filter to elements that likely contain substantive content
        const contentElements = Array.from(allElements).filter(el => {
            const text = el.textContent || '';
            // Skip elements with very little text
            if (text.length < 30)
                return false;
            // Skip elements that are likely navigation, headers, footers, etc.
            const tagName = el.tagName.toLowerCase();
            if (tagName === 'div') {
                // Only include divs that are likely content containers, not layout divs
                // Check for content characteristics
                const hasEnoughText = text.length > 100;
                const hasSentences = text.split('.').length > 2;
                const hasParagraphChild = el.querySelector('p') !== null;
                return hasEnoughText && hasSentences && !hasParagraphChild;
            }
            // Accept paragraph and article elements by default
            return true;
        });
        console.log(`Filtered down to ${contentElements.length} content elements`);
        // Tag elements for easier identification later
        contentElements.forEach((el, index) => {
            if (!el.getAttribute('data-deepcite-id')) {
                el.setAttribute('data-deepcite-id', `content-${index}`);
                // Add a subtle border to help visualize what's being analyzed
                el.style.border = '1px dashed rgba(47, 128, 237, 0.3)';
            }
        });
        // Extract text from these elements
        const contentTexts = contentElements
            .map(el => el.textContent)
            .filter(text => text.length > 30);
        // Also always include paragraph elements as a fallback
        const paragraphs = Array.from(document.getElementsByTagName('p'))
            .filter(p => p.textContent && p.textContent.length > 50)
            .map(p => p.textContent);
        // Combine and deduplicate manually instead of using Set
        const allTexts = [...contentTexts, ...paragraphs];
        const uniqueTexts = [];
        for (const text of allTexts) {
            if (!uniqueTexts.includes(text)) {
                uniqueTexts.push(text);
            }
        }
        console.log(`Final content extraction: ${uniqueTexts.length} text blocks`);
        return uniqueTexts;
    }
    /**
     * Enhanced claim detection using more precise rules
     * - Filters out subjective language and opinions
     * - Skips questions, emotional language, and speculative content
     * - Focuses on statements with factual indicators
     * - Requires presence of evidence-based language
     * - Detects statements with numeric data and proper nouns
     */
    isLikelyClaim(sentence) {
        // Skip very short sentences
        if (sentence.length < 20)
            return false;
        // Skip sentences with subjective/speculative language
        const hasSubjectiveIndicators = /\b(I think|I believe|in my opinion|I feel|it might be|it may be|we believe|probably|possibly|maybe|perhaps|likely|unlikely|seems to|could be|might be|may be|allegedly|supposedly|apparently)\b/i.test(sentence);
        if (hasSubjectiveIndicators)
            return false;
        // Skip questions (often not factual claims)
        if (sentence.trim().endsWith('?'))
            return false;
        // Skip emotional/opinion phrases
        const hasEmotionalLanguage = /\b(beautiful|ugly|wonderful|terrible|best|worst|amazing|awful|good|bad|love|hate|favorite|great|excellent|poor|superior|inferior)\b/i.test(sentence);
        if (hasEmotionalLanguage)
            return false;
        // Check for numbers
        const hasNumbers = /\d/.test(sentence);
        // Check for proper nouns (simplified)
        const hasProperNouns = /\s[A-Z][a-z]+/.test(sentence);
        // Enhanced claim indicators - expanded for better detection of fact-like language
        const hasClaimIndicators = /(found|showed|discovered|reported|according to|study|research|analysis|evidence|data|results|concluded|suggests|indicates|confirms|demonstrates|proves|supported by|measured|observed|conducted|survey|experiments|calculations|statistics|percent|percentage|proportion|scientific|researchers|scientists|experts|published|journal|paper|investigate|examine|analyze|determine|established|verify|confirmed|identify|document|record|reveal|show that|demonstrate that|indicate that|prove that|establish that|verified that)/i.test(sentence);
        // Force some sentences to be considered claims only if they don't have subjective indicators
        if (!hasSubjectiveIndicators && !hasEmotionalLanguage && (sentence.includes('climate') ||
            sentence.includes('research') ||
            sentence.includes('study') ||
            sentence.includes('found') ||
            sentence.includes('data') ||
            sentence.includes('showed'))) {
            return true;
        }
        return (hasNumbers || hasProperNouns) && hasClaimIndicators;
    }
    /**
     * Split text into sentences, handling common abbreviations
     */
    splitIntoSentences(text) {
        // Basic sentence splitting with some abbreviation handling
        return text
            .replace(/([.?!])\s+(?=[A-Z])/g, "$1|")
            .split("|")
            .map(s => s.trim())
            .filter(s => s.length > 0);
    }
    /**
     * Calculate relevance score based on enhanced heuristics
     * - Boosts statements with specific data, percentages, and statistics
     * - Rewards research references and evidence-based language
     * - Penalizes subjective elements like first-person pronouns
     * - Adjusts for future tense and non-verifiable content
     */
    calculateRelevance(sentence) {
        let score = 0.5; // Base score
        // Boost score for numbers (important for factual claims)
        if (/\d/.test(sentence))
            score += 0.15;
        // Give higher boost for percentages and statistics
        if (/\d+(\.\d+)?%|\d+ percent|\d+ percentage/i.test(sentence))
            score += 0.1;
        // Boost for proper nouns (entities being discussed)
        if (/\s[A-Z][a-z]+/.test(sentence))
            score += 0.1;
        // Substantial boost for research/evidence indicators
        if (/(study|research|found|showed|evidence|data|results|published|journal|paper)/i.test(sentence))
            score += 0.15;
        // Boost for specific verifiable terms
        if (/(according to|reported by|measured|observed|conducted|statistics|researchers|scientists)/i.test(sentence))
            score += 0.1;
        // Penalize very long sentences (more likely to contain mixed content)
        if (sentence.length > 200)
            score -= 0.1;
        // Penalize sentences with first-person pronouns (often opinions)
        if (/\b(I|we|our|my)\b/i.test(sentence))
            score -= 0.15;
        // Slight penalty for future tense (less verifiable)
        if (/\b(will|going to|shall|would)\b/i.test(sentence))
            score -= 0.05;
        return Math.min(Math.max(score, 0), 1); // Clamp between 0 and 1
    }
    /**
     * Extract claims from the current webpage
     */
    async extractClaims(maxClaims = 5) {
        const paragraphs = this.getMainContent();
        const claims = [];
        let totalProcessed = 0;
        // Fall back to rule-based approach if LLM fails or isn't available
        for (let pIndex = 0; pIndex < paragraphs.length; pIndex++) {
            const sentences = this.splitIntoSentences(paragraphs[pIndex]);
            for (const sentence of sentences) {
                totalProcessed++;
                if (this.isLikelyClaim(sentence)) {
                    const relevance = this.calculateRelevance(sentence);
                    // Clean the text by removing references
                    const cleanText = sentence.replace(/\[\d+\]/g, '');
                    claims.push({
                        id: ++this.claimCounter,
                        text: sentence,
                        cleanText,
                        context: {
                            page: 1,
                            paragraph: pIndex
                        },
                        relevance
                    });
                    if (claims.length >= maxClaims) {
                        return { claims, totalProcessed };
                    }
                }
            }
        }
        return { claims, totalProcessed };
    }
}
// Link to our external stylesheet that has all the styles
// Make sure to add this early to ensure styles are applied
function addStylesheet() {
    console.log('Adding stylesheet to document head');
    const existingStylesheets = document.querySelectorAll('link[href*="pdf-overlay.css"]');
    if (existingStylesheets.length > 0) {
        console.log('Stylesheet already exists, not adding again');
        return;
    }
    const linkToStyles = document.createElement('link');
    linkToStyles.rel = 'stylesheet';
    linkToStyles.href = chrome.runtime.getURL('styles/pdf-overlay.css');
    document.head.appendChild(linkToStyles);
    console.log('Stylesheet added:', linkToStyles.href);
}
// Creates a small sidebar toggle button fixed to the right edge of the screen
function createSidebarToggle() {
    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'deepcite-sidebar-toggle';
    toggleBtn.textContent = '»'; // Arrow icon
    // Position it fixed on the right, about halfway down
    toggleBtn.style.position = 'fixed';
    toggleBtn.style.right = '0';
    toggleBtn.style.top = '50%';
    toggleBtn.style.transform = 'translateY(-50%)';
    toggleBtn.style.width = '32px';
    toggleBtn.style.height = '48px';
    toggleBtn.style.backgroundColor = 'var(--primary-color, #2F80ED)';
    toggleBtn.style.color = '#fff';
    toggleBtn.style.border = 'none';
    toggleBtn.style.borderRadius = '8px 0 0 8px'; // Round left corners
    toggleBtn.style.cursor = 'pointer';
    toggleBtn.style.zIndex = '99999';
    toggleBtn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
    toggleBtn.style.fontSize = '16px';
    toggleBtn.style.fontWeight = 'bold';
    toggleBtn.style.transition = 'all 0.3s ease';
    // On hover, make the button slightly larger
    toggleBtn.addEventListener('mouseenter', () => {
        toggleBtn.style.width = '36px';
        toggleBtn.style.backgroundColor = 'var(--primary-color-hover, #1c68d3)';
    });
    toggleBtn.addEventListener('mouseleave', () => {
        toggleBtn.style.width = '32px';
        toggleBtn.style.backgroundColor = 'var(--primary-color, #2F80ED)';
    });
    // On click, open or close the claims overlay
    toggleBtn.addEventListener('click', () => {
        // First check if we need to run the analysis
        const hasRunAnalysis = toggleBtn.getAttribute('data-analysis-run') === 'true';
        const overlay = document.querySelector('.deepcite-claims-overlay');
        if (!hasRunAnalysis) {
            // If analysis hasn't been run yet, run it
            toggleBtn.setAttribute('data-analysis-run', 'true');
            toggleBtn.textContent = '⟳'; // Loading indicator
            toggleBtn.style.opacity = '0.8';
            // Run the appropriate analysis based on content type
            if (document.contentType === 'application/pdf' ||
                window.location.pathname.toLowerCase().endsWith('.pdf')) {
                // For PDFs
                chrome.storage.local.get(['openaiKey'], result => {
                    analyzePDF(result.openaiKey);
                    // After analysis complete
                    toggleBtn.textContent = '»';
                    toggleBtn.style.opacity = '1';
                });
            }
            else {
                // For web pages
                chrome.storage.local.get(['openaiKey'], async (result) => {
                    // Use Content Extractor to get main content
                    const extractor = new ContentExtractor();
                    await runExtraction(extractor);
                    // After analysis complete
                    toggleBtn.textContent = '»';
                    toggleBtn.style.opacity = '1';
                });
            }
        }
        // Toggle overlay visibility
        if (overlay) {
            if (overlay.classList.contains('closed') || overlay.style.display === 'none') {
                overlay.classList.remove('closed', 'minimized');
                overlay.style.display = 'block';
                toggleBtn.textContent = '«'; // Change arrow direction
            }
            else {
                overlay.classList.add('minimized');
                toggleBtn.textContent = '»';
            }
        }
    });
    document.body.appendChild(toggleBtn);
    return toggleBtn;
}
// Add stylesheet immediately
addStylesheet();
// Helper function to determine color based on confidence level
function getConfidenceColor(confidence) {
    if (confidence >= 0.8)
        return 'var(--high-confidence)'; // High confidence - green
    if (confidence >= 0.5)
        return 'var(--medium-confidence)'; // Medium confidence - yellow/amber
    return 'var(--low-confidence)'; // Low confidence - red
}
// Function to add a claim to the unified claims overlay
function addClaimToOverlay(overlay, claim, sources) {
    const claimDiv = document.createElement('div');
    claimDiv.className = 'deepcite-claim-item';
    // Create the basic claim information
    let claimHTML = `
    ${claim.pdfLocation ? `
      <div class="pdf-claim-location">
        Page ${claim.pdfLocation.pageNum}, Paragraph ${claim.pdfLocation.paragraph + 1}
      </div>
    ` : ''}
    <div class="deepcite-claim-text">${claim.text}</div>
    ${claim.confidence !== undefined ? `
      <div class="deepcite-claim-confidence">
        <span style="font-weight: bold;">Certainty:</span>
        <span class="confidence-meter" style="
          width: ${Math.round(claim.confidence * 100)}px;
          background-color: ${getConfidenceColor(claim.confidence)};
        "></span>
        <span class="confidence-text" style="color: ${getConfidenceColor(claim.confidence)}; font-weight: 500;">
          ${Math.round(claim.confidence * 100)}%
        </span>
      </div>
    ` : ''}
    <div class="deepcite-claim-sources">
      <div class="deepcite-claim-sources-header">Sources (${sources.length}):</div>
  `;
    // Add all sources to the claim or show "no sources" message
    if (sources.length === 0) {
        claimHTML += `
      <div class="deepcite-claim-source-item">
        <div class="deepcite-source-title">
          <span style="color: #666; font-style: italic;">No relevant sources found</span>
        </div>
      </div>
    `;
    }
    else {
        sources.forEach((source, index) => {
            // Skip "no sources" placeholder entries
            if (source.title === "No relevant sources found" || source.url === "#") {
                claimHTML += `
          <div class="deepcite-claim-source-item">
            <div class="deepcite-source-title">
              <span style="color: #666; font-style: italic;">No relevant sources found</span>
            </div>
          </div>
        `;
            }
            else {
                claimHTML += `
          <div class="deepcite-claim-source-item">
            <div class="deepcite-source-title">
              <a href="${source.url}" target="_blank">${source.title}</a>
              <span class="deepcite-source-confidence">(${Math.round(source.score * 100)}% confidence)</span>
            </div>
            ${source.highlights && source.highlights.length > 0 ?
                    `<div class="deepcite-source-highlight">"${source.highlights[0]}"</div>` : ''}
            ${index < sources.length - 1 ? '<hr class="deepcite-source-divider">' : ''}
          </div>
        `;
            }
        });
    }
    // Close the sources div
    claimHTML += `</div>`;
    claimDiv.innerHTML = claimHTML;
    // Add click handler to highlight the claim text in the document
    claimDiv.addEventListener('click', () => {
        // Find the element with the claim text and scroll to it
        const elements = document.querySelectorAll('.exa-claim-highlight');
        for (let i = 0; i < elements.length; i++) {
            const elem = elements[i];
            if (elem.textContent?.includes(claim.cleanText)) {
                elem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                elem.classList.add('exa-claim-highlight-flash');
                setTimeout(() => {
                    elem.classList.remove('exa-claim-highlight-flash');
                }, 1500);
                break;
            }
        }
    });
    overlay.appendChild(claimDiv);
}
// Function to highlight text and add tooltip with source information
// This is the core UI component that makes claims interactive
// and displays verification results to the user
// Helper function to create a consistent DEEPCITE badge
function createDeepCiteBadge() {
    const badge = document.createElement('span');
    badge.className = 'deepcite-badge';
    badge.textContent = 'DEEPCITE';
    badge.title = 'This element contains a factual claim verified by DeepCite';
    // We're now using CSS defined in pdf-overlay.css
    // No need to add event listeners as they're handled via CSS :hover
    return badge;
}
function highlightClaim(claim, sources) {
    console.log('Starting highlight process for claim:', claim.cleanText);
    // Check if this claim already has a data-claim-id attribute set in the DOM
    // to avoid duplicate highlights
    const existingHighlight = document.querySelector(`[data-claim-id="${claim.id}"]`);
    if (existingHighlight) {
        console.log('This claim is already highlighted, skipping duplicate highlight');
        return true;
    }
    // Try to find the claim in the actual page content
    const paragraphs = document.getElementsByTagName('p');
    console.log('Found paragraphs:', paragraphs.length);
    let foundMatch = false;
    for (let i = 0; i < paragraphs.length; i++) {
        const p = paragraphs[i];
        const cleanParagraphText = p.textContent?.replace(/\[\d+\]/g, '') || '';
        if (cleanParagraphText.includes(claim.cleanText)) {
            console.log('Found matching paragraph!', p.getAttribute('data-deepcite-id'));
            foundMatch = true;
            try {
                // Enhanced styling for better visibility
                p.style.backgroundColor = 'rgba(47, 128, 237, 0.2)'; // Increased opacity
                p.style.borderLeft = '4px solid rgba(47, 128, 237, 0.6)'; // Thicker border, more opacity
                p.style.padding = '8px'; // Increased padding
                p.style.cursor = 'pointer';
                p.style.transition = 'all 0.25s ease';
                p.style.borderRadius = '3px'; // Subtle rounded corners
                p.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.05)'; // Subtle shadow
                // Mark this paragraph
                p.setAttribute('data-claim-id', claim.id.toString());
                // Add the improved DEEPCITE badge
                const deepciteBadge = createDeepCiteBadge();
                // Add confidence score to the badge if available
                if (claim.confidence !== undefined) {
                    const confidencePercent = Math.round(claim.confidence * 100);
                    deepciteBadge.title = `Confidence score: ${confidencePercent}%`;
                }
                // Insert at the beginning of the paragraph
                if (p.firstChild) {
                    p.insertBefore(deepciteBadge, p.firstChild);
                }
                else {
                    p.appendChild(deepciteBadge);
                }
                console.log('Applied enhanced styles to paragraph');
            }
            catch (err) {
                console.error('Error highlighting paragraph:', err);
            }
            // Create direct hover handler on the paragraph
            let currentTooltip = null;
            let tooltipTimeout = null;
            let currentSourceIndex = 0;
            // Function to update tooltip content
            const updateTooltip = () => {
                if (!currentTooltip)
                    return;
                // We'll update the tooltip to provide a better view of multiple sources
                let tooltipHTML = '';
                // Add claim confidence if available - with visual meter
                if (claim.confidence !== undefined) {
                    tooltipHTML += `
            <div class="exa-claim-confidence" style="margin-bottom: 10px; padding: 6px 8px; background: rgba(47, 128, 237, 0.05); border-radius: 6px; font-size: 13px;">
              <span style="font-weight: bold;">Certainty:</span> 
              <span style="display: inline-block; height: 8px; border-radius: 4px; margin: 0 6px; width: ${Math.round(claim.confidence * 100)}px; background-color: ${getConfidenceColor(claim.confidence)};">
              </span>
              <span style="font-weight: 500; margin-left: 4px; color: ${getConfidenceColor(claim.confidence)}">
                ${Math.round(claim.confidence * 100)}%
              </span>
            </div>
          `;
                }
                // Add sources header
                tooltipHTML += `<div style="font-weight: 600; margin-bottom: 10px; color: #333;">
          Sources (${sources.length})
        </div>`;
                // Display sources
                if (sources.length <= 2) {
                    // Show all sources in a compact view
                    tooltipHTML += sources.map((source, index) => {
                        const srcFavicon = `https://www.google.com/s2/favicons?domain=${new URL(source.url).hostname}`;
                        return `
              <div style="margin-bottom: 10px; padding: 6px;">
                <div style="display: flex; align-items: center; margin-bottom: 6px;">
                  <img src="${srcFavicon}" alt="Source icon" style="width: 16px; height: 16px; margin-right: 8px; border-radius: 2px;">
                  <strong>${source.title}</strong>
                  <span style="display: inline-block; padding: 2px 6px; background: rgba(47, 128, 237, 0.05); border-radius: 4px; font-size: 12px; margin-left: 8px; color: #666;">
                    ${Math.round(source.score * 100)}%
                  </span>
                </div>
                <a href="${source.url}" target="_blank" style="color: #007AFF; text-decoration: none;">View source</a>
                ${index < sources.length - 1 ? '<hr style="margin: 10px 0; border: 0; border-top: 1px solid #eee;">' : ''}
              </div>
            `;
                    }).join('');
                }
                else {
                    // Use pagination for 3+ sources
                    const source = sources[currentSourceIndex];
                    const srcFavicon = `https://www.google.com/s2/favicons?domain=${new URL(source.url).hostname}`;
                    tooltipHTML += `
            <div style="margin-bottom: 10px; padding: 6px;">
              <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <img src="${srcFavicon}" alt="Source icon" style="width: 16px; height: 16px; margin-right: 8px; border-radius: 2px;">
                <strong>${source.title}</strong>
                <span style="display: inline-block; padding: 2px 6px; background: rgba(47, 128, 237, 0.05); border-radius: 4px; font-size: 12px; margin-left: 8px; color: #666;">
                  ${Math.round(source.score * 100)}%
                </span>
              </div>
              <a href="${source.url}" target="_blank" style="color: #007AFF; text-decoration: none;">View source</a>
            </div>
            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 10px; padding-top: 8px; border-top: 1px solid #eee;">
              <button id="prev-btn" ${currentSourceIndex === 0 ? 'disabled' : ''} style="background: #f8f9fa; border: 1px solid #eee; color: #333; cursor: pointer; padding: 4px 10px; border-radius: 6px;">
                ← Previous
              </button>
              <span>${currentSourceIndex + 1}/${sources.length}</span>
              <button id="next-btn" ${currentSourceIndex === sources.length - 1 ? 'disabled' : ''} style="background: #f8f9fa; border: 1px solid #eee; color: #333; cursor: pointer; padding: 4px 10px; border-radius: 6px;">
                Next →
              </button>
            </div>
          `;
                }
                currentTooltip.innerHTML = tooltipHTML;
                // Add event listeners to buttons
                if (sources.length > 2) {
                    const prevBtn = currentTooltip.querySelector('#prev-btn');
                    const nextBtn = currentTooltip.querySelector('#next-btn');
                    if (prevBtn) {
                        prevBtn.addEventListener('click', () => {
                            if (currentSourceIndex > 0) {
                                currentSourceIndex--;
                                updateTooltip();
                            }
                        });
                    }
                    if (nextBtn) {
                        nextBtn.addEventListener('click', () => {
                            if (currentSourceIndex < sources.length - 1) {
                                currentSourceIndex++;
                                updateTooltip();
                            }
                        });
                    }
                }
            };
            const clearTooltipTimeout = () => {
                if (tooltipTimeout) {
                    clearTimeout(tooltipTimeout);
                    tooltipTimeout = null;
                }
            };
            const startTooltipTimeout = () => {
                clearTooltipTimeout();
                tooltipTimeout = window.setTimeout(() => {
                    if (currentTooltip) {
                        currentTooltip.remove();
                        currentTooltip = null;
                    }
                }, 300);
            };
            // Add hover handler directly to the paragraph
            p.addEventListener('mouseenter', () => {
                clearTooltipTimeout();
                // Remove any existing tooltips
                const existingTooltip = document.querySelector('.exa-tooltip');
                if (existingTooltip)
                    existingTooltip.remove();
                const newTooltip = document.createElement('div');
                newTooltip.className = 'exa-tooltip';
                newTooltip.style.position = 'fixed';
                newTooltip.style.background = 'white';
                newTooltip.style.border = '1px solid #e0e0e0';
                newTooltip.style.boxShadow = '0 8px 24px rgba(0,0,0,0.1)';
                newTooltip.style.padding = '14px 18px';
                newTooltip.style.borderRadius = '8px';
                newTooltip.style.fontSize = '14px';
                newTooltip.style.maxWidth = '320px';
                newTooltip.style.zIndex = '999999';
                newTooltip.style.color = '#333';
                newTooltip.style.backdropFilter = 'blur(10px)';
                newTooltip.style.opacity = '0';
                newTooltip.style.transform = 'translateY(8px)';
                newTooltip.style.transition = 'opacity 0.25s, transform 0.25s';
                newTooltip.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
                newTooltip.style.lineHeight = '1.5';
                // Position the tooltip
                const rect = p.getBoundingClientRect();
                newTooltip.style.top = `${rect.bottom + 5}px`;
                newTooltip.style.left = `${rect.left}px`;
                document.body.appendChild(newTooltip);
                currentTooltip = newTooltip;
                // Add animation
                setTimeout(() => {
                    newTooltip.style.opacity = '1';
                    newTooltip.style.transform = 'translateY(0)';
                }, 10);
                // Initial tooltip content
                updateTooltip();
                // Add hover handlers to tooltip
                newTooltip.addEventListener('mouseenter', clearTooltipTimeout);
                newTooltip.addEventListener('mouseleave', startTooltipTimeout);
            });
            p.addEventListener('mouseleave', startTooltipTimeout);
            // Only process the first matching paragraph
            break;
        }
    }
    // Return whether we found and highlighted a match
    return foundMatch;
}
async function isPDF() {
    return document.contentType === 'application/pdf' ||
        window.location.pathname.toLowerCase().endsWith('.pdf');
}
/**
 * Create a draggable claims overlay panel
 * Improved with smooth animations and draggable functionality
 * @param isPDF Whether this is being used in PDF mode
 * @returns The overlay HTML element
 */
async function createClaimsOverlay(isPDF = false) {
    console.log('Creating claims overlay, isPDF:', isPDF);
    // Clean up any temporary UI elements when creating/reopening overlay
    cleanupEphemeralElements();
    // Check if overlay already exists
    let overlay = document.querySelector('.deepcite-claims-overlay');
    console.log('Existing overlay found:', !!overlay);
    if (overlay) {
        // If overlay exists, keep it in its current state (closed/minimized)
        // We'll control visibility with the toggle button now
        console.log('Using existing overlay');
        // Update the header to show we're processing again
        const headerSmall = overlay.querySelector('.deepcite-claims-header small');
        if (headerSmall) {
            headerSmall.textContent = 'Processing...';
        }
        return overlay;
    }
    console.log('Creating new overlay');
    overlay = document.createElement('div');
    overlay.className = 'deepcite-claims-overlay';
    // Add close button
    const closeButton = document.createElement('button');
    closeButton.className = 'deepcite-overlay-close';
    closeButton.textContent = '×';
    closeButton.title = 'Toggle sidebar';
    // Toggle button handling
    closeButton.addEventListener('click', (e) => {
        e.stopPropagation();
        if (overlay.classList.contains('minimized')) {
            // If minimized, expand it back
            overlay.classList.remove('minimized');
            closeButton.title = 'Toggle sidebar';
        }
        else {
            // If expanded, minimize it
            overlay.classList.add('minimized');
            closeButton.title = 'Expand sidebar';
        }
    });
    // Add double-click to fully close
    closeButton.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        overlay.classList.add('closed');
        // Set a timeout to fully hide it after animation completes
        setTimeout(() => {
            if (overlay.classList.contains('closed')) {
                overlay.style.display = 'none';
                // Clean up any ephemeral UI elements when closing panel
                cleanupEphemeralElements();
            }
        }, 300); // match the CSS transition time
    });
    overlay.appendChild(closeButton);
    // Add header
    const header = document.createElement('div');
    header.className = 'deepcite-claims-header';
    header.innerHTML = `
    <h3>Detected Claims</h3>
    <small>Processing...</small>
  `;
    overlay.appendChild(header);
    // Make the overlay draggable using the header as the handle
    makeDraggable(overlay, header);
    // Add a "fully close" button at the bottom of the panel with improved styling
    const closeCompletelyButton = document.createElement('button');
    closeCompletelyButton.className = 'deepcite-close-panel-button';
    closeCompletelyButton.textContent = 'Close Panel';
    closeCompletelyButton.addEventListener('click', () => {
        overlay.classList.add('closed');
        // Set a timeout to fully hide it after animation completes
        setTimeout(() => {
            if (overlay.classList.contains('closed')) {
                overlay.style.display = 'none';
                // Clean up any ephemeral UI elements when closing panel
                cleanupEphemeralElements();
            }
        }, 300); // match the CSS transition time
    });
    overlay.appendChild(closeCompletelyButton);
    document.body.appendChild(overlay);
    // Hide the overlay by default - will be shown via the toggle button
    overlay.style.display = 'none';
    overlay.classList.add('closed');
    return overlay;
}
/**
 * Helper function to make an element draggable
 * @param element The element to make draggable
 * @param handle The drag handle (usually the header)
 */
function makeDraggable(element, handle) {
    let posX = 0, posY = 0, posLeft = 0, posTop = 0;
    const dragMouseDown = (e) => {
        e.preventDefault();
        // Get starting positions
        posLeft = element.offsetLeft;
        posTop = element.offsetTop;
        posX = e.clientX;
        posY = e.clientY;
        // Add event listeners for drag and release
        document.addEventListener('mousemove', elementDrag);
        document.addEventListener('mouseup', closeDragElement);
        // Add dragging class for styling
        element.classList.add('dragging');
    };
    const elementDrag = (e) => {
        e.preventDefault();
        // Calculate the new position
        const dx = posX - e.clientX;
        const dy = posY - e.clientY;
        posX = e.clientX;
        posY = e.clientY;
        // Check if the new position would be within screen bounds
        const newTop = element.offsetTop - dy;
        const newLeft = element.offsetLeft - dx;
        // Stay within viewport 
        const buffer = 20; // Minimum distance from edge
        if (newTop >= buffer && newTop + element.offsetHeight <= window.innerHeight - buffer) {
            element.style.top = `${newTop}px`;
        }
        if (newLeft >= buffer && newLeft + element.offsetWidth <= window.innerWidth - buffer) {
            element.style.left = `${newLeft}px`;
        }
    };
    const closeDragElement = () => {
        // Stop moving when mouse button is released
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('mouseup', closeDragElement);
        // Remove dragging class
        element.classList.remove('dragging');
    };
    // Attach the mousedown event listener to the handle
    handle.addEventListener('mousedown', dragMouseDown);
    // Apply initial draggable styling
    handle.style.cursor = 'move';
    element.style.position = 'fixed';
}
/**
 * Cleans up temporary UI elements when opening/closing the panel
 * This ensures a clean state
 */
function cleanupEphemeralElements() {
    // Remove any floating tooltips
    const tooltips = document.querySelectorAll('.exa-tooltip');
    tooltips.forEach(tooltip => tooltip.remove());
    // Remove any temporary status indicators
    const indicators = document.querySelectorAll('[data-temporary-indicator]');
    indicators.forEach(indicator => indicator.remove());
}
async function analyzePDF(openaiKey) {
    const overlay = await createClaimsOverlay(true);
    // Get the Exa API key from storage
    const { exaKey } = await new Promise(resolve => {
        chrome.storage.local.get(['exaKey'], (result) => resolve(result));
    });
    // Check for missing API keys
    if (!exaKey || exaKey === '') {
        console.error('Exa API key is missing');
        // Update the overlay to show an error
        const header = overlay.querySelector('.deepcite-claims-header small');
        if (header) {
            header.textContent = 'API key missing. Please set in options.';
        }
        // Add an error message to the overlay
        const errorDiv = document.createElement('div');
        errorDiv.className = 'deepcite-claim-item';
        errorDiv.innerHTML = `
      <div class="deepcite-claim-text" style="color: #dc3545; text-align: center; padding: 15px;">
        Exa API key is missing. Please set it in the extension options.
      </div>
      <button id="open-options-btn" style="margin: 10px auto; display: block; padding: 8px 16px; background: #f8f9fa; border: 1px solid #eee; color: #333; cursor: pointer; border-radius: 6px;">
        Open Options
      </button>
    `;
        overlay.appendChild(errorDiv);
        // Add click handler for the options button
        const optionsBtn = errorDiv.querySelector('#open-options-btn');
        if (optionsBtn) {
            optionsBtn.addEventListener('click', () => {
                chrome.runtime.openOptionsPage();
            });
        }
        return;
    }
    // Create a temporary status indicator for analysis
    const statusIndicator = document.createElement('div');
    statusIndicator.setAttribute('data-temporary-indicator', 'true');
    statusIndicator.style.position = 'fixed';
    statusIndicator.style.top = '20px';
    statusIndicator.style.right = '20px';
    statusIndicator.style.padding = '12px 16px';
    statusIndicator.style.backgroundColor = 'var(--primary-color)';
    statusIndicator.style.color = 'white';
    statusIndicator.style.zIndex = '99999';
    statusIndicator.style.borderRadius = 'var(--border-radius-md)';
    statusIndicator.style.fontWeight = 'bold';
    statusIndicator.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
    statusIndicator.style.transition = 'all 0.5s cubic-bezier(0.16, 1, 0.3, 1)';
    statusIndicator.style.fontFamily = 'var(--font-family)';
    statusIndicator.style.fontSize = '14px';
    statusIndicator.style.display = 'flex';
    statusIndicator.style.alignItems = 'center';
    statusIndicator.style.opacity = '0';
    statusIndicator.style.transform = 'translateY(-10px)';
    statusIndicator.innerHTML = '<span style="margin-right: 8px; font-size: 16px;">📄</span> Analyzing PDF...';
    document.body.appendChild(statusIndicator);
    // Animate in
    setTimeout(() => {
        statusIndicator.style.opacity = '1';
        statusIndicator.style.transform = 'translateY(0)';
    }, 10);
    try {
        const pdfHandler = new PDFHandler(window.location.href);
        await pdfHandler.init();
        const content = await pdfHandler.getAllContent();
        let useLLM = false;
        // Try to use LLM extraction if OpenAI key is available
        if (openaiKey && openaiKey !== '') {
            try {
                console.log('Testing LLM extraction for PDF...');
                const llmExtractor = new LLMExtractor(openaiKey);
                const testResult = await llmExtractor.extractClaimsFromChunk("This is a test claim.");
                if (testResult && testResult.claims.length > 0) {
                    console.log('LLM extraction successful, will use it for PDF content');
                    useLLM = true;
                    // Process full content with LLM extraction
                    const fullResults = await llmExtractor.extractClaims(content);
                    if (fullResults && fullResults.claims.length > 0) {
                        // Add context information to each claim
                        const claims = fullResults.claims.map((text, index) => ({
                            id: index + 1,
                            text,
                            cleanText: text.replace(/\[\d+\]/g, ''), // Remove reference numbers if present
                            context: {
                                page: 1, // We'll update this later
                                paragraph: 0
                            },
                            relevance: 0.8, // Default high relevance since LLM already filtered
                            confidence: fullResults.confidence[index] || 0.7 // Use confidence from LLM or default
                        }));
                        // Update the header of the overlay
                        const header = overlay.querySelector('.deepcite-claims-header small');
                        if (header) {
                            header.textContent = `${claims.length} claims found`;
                        }
                        // Process the claims
                        processPDFClaims(claims, pdfHandler, overlay);
                    }
                    else {
                        console.log('LLM extraction returned no claims, falling back to rule-based');
                        useLLM = false;
                    }
                }
                else {
                    console.log('LLM test failed, falling back to rule-based extraction');
                }
            }
            catch (error) {
                console.error('LLM extraction failed, using rule-based approach:', error);
                useLLM = false;
            }
        }
        else {
            console.log('No OpenAI key provided, using rule-based extraction only');
        }
        // Use rule-based approach if LLM failed or wasn't attempted
        if (!useLLM) {
            console.log('Using rule-based extraction for PDF');
            const extractor = new ContentExtractor();
            const extractionResult = await extractor.extractClaims(10);
            // Add confidence scores to all claims
            for (const claim of extractionResult.claims) {
                claim.confidence = 0.7; // Set a default confidence score
            }
            // Update the header of the overlay
            const header = overlay.querySelector('.deepcite-claims-header small');
            if (header) {
                header.textContent = `${extractionResult.claims.length} claims found`;
            }
            processPDFClaims(extractionResult.claims, pdfHandler, overlay);
        }
        // Update status indicator to show completion
        statusIndicator.innerHTML = '<span style="margin-right: 8px; font-size: 16px;">✓</span> PDF Analysis Complete';
    }
    catch (error) {
        console.error('PDF analysis failed:', error);
        // Update status indicator to show error
        statusIndicator.style.backgroundColor = '#dc3545';
        statusIndicator.innerHTML = '<span style="margin-right: 8px; font-size: 16px;">❌</span> PDF Analysis Failed';
    }
    // Remove status indicator after animation
    setTimeout(() => {
        statusIndicator.style.opacity = '0';
        statusIndicator.style.transform = 'translateY(-10px)';
        setTimeout(() => statusIndicator.remove(), 500);
    }, 5000);
}
// Helper function to process PDF claims
async function processPDFClaims(claims, pdfHandler, overlay) {
    // Sort claims by confidence for better presentation
    const sortedClaims = [...claims].sort((a, b) => {
        const confA = a.confidence !== undefined ? a.confidence : 0;
        const confB = b.confidence !== undefined ? b.confidence : 0;
        return confB - confA; // Sort in descending order
    });
    // Apply more strict filtering for PDF claims
    for (const claim of sortedClaims) {
        // Skip claims with low fact certainty (increased threshold)
        if (claim.confidence !== undefined && claim.confidence < 0.65) {
            console.log(`Skipping low confidence claim (${claim.confidence}): ${claim.text.substring(0, 50)}...`);
            continue;
        }
        // Skip claims that have subjective language patterns
        if (/\b(I think|I believe|in my opinion|we feel|might be|may be|probably|possibly|maybe|perhaps|could be|allegedly)\b/i.test(claim.text)) {
            console.log(`Skipping subjective claim: ${claim.text.substring(0, 50)}...`);
            continue;
        }
        // Find location in PDF to add to claim data
        const location = pdfHandler.findTextLocation(claim.cleanText);
        const pdfClaim = { ...claim, pdfLocation: location };
        chrome.runtime.sendMessage({
            type: 'VERIFY_CLAIM',
            claim: pdfClaim
        }, response => {
            if (response && response.success && response.results && response.results.length > 0) {
                const sources = response.results;
                // Add to the overlay using our unified function
                addClaimToOverlay(overlay, pdfClaim, sources);
                // Ensure the overlay is visible whenever results are added
                overlay.classList.remove('closed', 'minimized');
                overlay.style.display = 'block';
                // For PDFs, override the click handler to navigate to the page
                const lastClaimItem = overlay.querySelector('.deepcite-claim-item:last-child');
                if (lastClaimItem && location) {
                    lastClaimItem.addEventListener('click', () => {
                        // Most PDF viewers support #page=N for navigation
                        window.location.hash = `#page=${location.pageNum}`;
                    });
                }
            }
            else {
                // Show "no sources found" message when API fails
                const noSources = [];
                // Add to the overlay with no sources
                addClaimToOverlay(overlay, pdfClaim, noSources);
                // Ensure the overlay is visible whenever results are added
                overlay.classList.remove('closed', 'minimized');
                overlay.style.display = 'block';
            }
        });
    }
}
// Main initialization
chrome.storage.local.get(['openaiKey', 'exaKey', 'highlightsEnabled'], async (result) => {
    // Log the key availability (but not the actual value for security)
    console.log('OpenAI key available:', !!result.openaiKey && result.openaiKey !== '');
    console.log('Exa key available:', !!result.exaKey && result.exaKey !== '');
    console.log('Highlights enabled:', result.highlightsEnabled !== false); // Default to true if undefined
    // Create the overlay ahead of time (it will remain hidden)
    const isPdfPage = await isPDF();
    await createClaimsOverlay(isPdfPage);
    // Create the sidebar toggle button (which replaces the analyze buttons)
    const toggleBtn = createSidebarToggle();
    // Check for missing API keys - we'll handle this when the toggle is clicked
    if (!result.exaKey || result.exaKey === '') {
        console.warn('Exa API key is missing');
        // We'll still show the button, but it will display an error when clicked
        toggleBtn.title = 'DeepCite (API key missing)';
        toggleBtn.style.backgroundColor = '#dc3545'; // Red to indicate error
    }
});
// Any function that would create demonstration highlights with dummy sources
// has been completely removed - we now only display real API-verified results
async function runExtraction(extractor) {
    console.log('Running rule-based extraction');
    // Create a temporary status indicator
    const statusIndicator = document.createElement('div');
    statusIndicator.setAttribute('data-temporary-indicator', 'true');
    statusIndicator.style.position = 'fixed';
    statusIndicator.style.top = '20px';
    statusIndicator.style.right = '20px';
    statusIndicator.style.padding = '12px 16px';
    statusIndicator.style.backgroundColor = 'var(--primary-color)';
    statusIndicator.style.color = 'white';
    statusIndicator.style.zIndex = '99999';
    statusIndicator.style.borderRadius = 'var(--border-radius-md)';
    statusIndicator.style.fontWeight = 'bold';
    statusIndicator.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
    statusIndicator.style.transition = 'all 0.5s cubic-bezier(0.16, 1, 0.3, 1)';
    statusIndicator.style.fontFamily = 'var(--font-family)';
    statusIndicator.style.fontSize = '14px';
    statusIndicator.style.display = 'flex';
    statusIndicator.style.alignItems = 'center';
    statusIndicator.style.opacity = '0';
    statusIndicator.style.transform = 'translateY(-10px)';
    statusIndicator.innerHTML = '<span style="margin-right: 8px; font-size: 16px;">🔍</span> DeepCite Analysis Active';
    document.body.appendChild(statusIndicator);
    // Animate in
    setTimeout(() => {
        statusIndicator.style.opacity = '1';
        statusIndicator.style.transform = 'translateY(0)';
    }, 10);
    // Remove status indicator after 5 seconds with animation
    setTimeout(() => {
        statusIndicator.style.opacity = '0';
        statusIndicator.style.transform = 'translateY(-10px)';
        setTimeout(() => statusIndicator.remove(), 500);
    }, 5000);
    // Find potential factual paragraphs to highlight
    const allParagraphs = document.querySelectorAll('p');
    const candidateParagraphs = [];
    // Look for paragraphs that might contain factual claims
    for (let i = 0; i < allParagraphs.length; i++) {
        const p = allParagraphs[i];
        if (p.textContent && p.textContent.length > 80) {
            // Try to detect if this paragraph has factual content
            const text = p.textContent.toLowerCase();
            // Skip paragraphs with primarily subjective content
            const hasSubjectiveIndicators = /(I think|I believe|in my opinion|we feel|might be|may be|probably|possibly|maybe|perhaps|could be|allegedly)/i.test(text);
            const hasEmotionalLanguage = /(beautiful|ugly|wonderful|terrible|best|worst|amazing|awful|good|bad|love|hate|favorite)/i.test(text);
            if (hasSubjectiveIndicators && hasEmotionalLanguage) {
                continue; // Skip this paragraph
            }
            const hasNumbers = /\d/.test(text);
            const hasProperNouns = /\s[A-Z][a-z]+/.test(p.textContent);
            // Enhanced fact indicators with stronger emphasis on verifiable sources
            const hasFactIndicators = /(study|research|found|showed|according to|evidence|data|results|published|journal|measure|observe|statistic|percent|survey|experiment)/i.test(text);
            // Require more evidence for a paragraph to be considered factual
            if ((hasNumbers || (hasProperNouns && !hasSubjectiveIndicators)) && hasFactIndicators) {
                candidateParagraphs.push(p);
            }
        }
    }
    // Highlight up to 2 paragraphs maximum
    const paragraphsToHighlight = candidateParagraphs.slice(0, Math.min(2, candidateParagraphs.length));
    paragraphsToHighlight.forEach(p => {
        // Create a wrapper around the paragraph to allow removal
        const wrapper = document.createElement('div');
        wrapper.style.position = 'relative';
        wrapper.style.backgroundColor = 'rgba(47, 128, 237, 0.15)';
        wrapper.style.borderLeft = '3px solid rgba(47, 128, 237, 0.5)';
        wrapper.style.padding = '8px';
        wrapper.style.borderRadius = '3px';
        wrapper.style.marginBottom = '10px';
        wrapper.style.transition = 'all 0.3s ease';
        // Create close button
        const closeBtn = document.createElement('button');
        closeBtn.style.position = 'absolute';
        closeBtn.style.top = '5px';
        closeBtn.style.right = '5px';
        closeBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        closeBtn.style.color = '#666';
        closeBtn.style.border = 'none';
        closeBtn.style.borderRadius = '50%';
        closeBtn.style.width = '20px';
        closeBtn.style.height = '20px';
        closeBtn.style.fontSize = '12px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.display = 'flex';
        closeBtn.style.alignItems = 'center';
        closeBtn.style.justifyContent = 'center';
        closeBtn.textContent = '×';
        closeBtn.title = 'Remove highlight';
        // Add a consistent DEEPCITE badge
        const tagSpan = createDeepCiteBadge();
        tagSpan.style.marginBottom = '8px';
        tagSpan.style.marginLeft = '0';
        // Clone the paragraph
        const pClone = p.cloneNode(true);
        // Add event listeners
        closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            wrapper.style.opacity = '0';
            setTimeout(() => wrapper.remove(), 300);
        });
        // Append everything
        wrapper.appendChild(closeBtn);
        wrapper.appendChild(tagSpan);
        wrapper.appendChild(pClone);
        // Replace the original paragraph with our wrapped version
        p.style.display = 'none'; // Hide original but keep in DOM for structure
        p.parentNode?.insertBefore(wrapper, p.nextSibling);
        // Auto-remove after 30 seconds if not interacted with
        setTimeout(() => {
            if (document.body.contains(wrapper)) {
                wrapper.style.opacity = '0';
                setTimeout(() => {
                    if (document.body.contains(wrapper)) {
                        wrapper.remove();
                        p.style.display = ''; // Restore original paragraph
                    }
                }, 300);
            }
        }, 30000);
    });
    // If no paragraphs were found, don't leave the user confused
    if (paragraphsToHighlight.length === 0) {
        console.log('No factual paragraphs detected for demonstration');
    }
    // Extract claims using rule-based approach
    const result = await extractor.extractClaims(10); // Increase to 10 claims for better results
    console.log('Rule-based extraction found claims:', result.claims.length);
    // Create claims overlay
    const overlay = await createClaimsOverlay(false);
    overlay.style.display = 'block';
    if (result.claims.length > 0) {
        const header = overlay.querySelector('.deepcite-claims-header small');
        if (header) {
            header.textContent = `${result.claims.length} claims found`;
        }
        // Process actual claims
        for (const claim of result.claims) {
            // Add a default confidence score if one isn't present
            claim.confidence = claim.confidence ?? 0.7; // Use a consistent medium confidence score
            // Empty array for when API fails - will show "No relevant sources found"
            const noSources = [];
            try {
                // Try to verify with API and only show results if successful
                chrome.runtime.sendMessage({
                    type: 'VERIFY_CLAIM',
                    claim
                }, response => {
                    if (response && response.success && response.results && response.results.length > 0) {
                        console.log('Successfully verified claim with API');
                        highlightClaim(claim, response.results);
                        addClaimToOverlay(overlay, claim, response.results);
                        // Ensure overlay is visible
                        overlay.classList.remove('closed', 'minimized');
                        overlay.style.display = 'block';
                    }
                    else {
                        console.log('No sources found for claim');
                        highlightClaim(claim, noSources);
                        addClaimToOverlay(overlay, claim, noSources);
                        // Ensure overlay is visible
                        overlay.classList.remove('closed', 'minimized');
                        overlay.style.display = 'block';
                    }
                });
                // Only show actual API results or "No sources found" - no dummy data
            }
            catch (err) {
                console.log('Error during claim verification, showing no sources found');
                // Only try to highlight if text exists on the page
                const highlighted = highlightClaim(claim, noSources);
                if (!highlighted) {
                    console.log('No matching content found for claim, only adding to sidebar');
                }
                // Add to the overlay regardless
                addClaimToOverlay(overlay, claim, noSources);
                // Ensure overlay is visible
                overlay.classList.remove('closed', 'minimized');
                overlay.style.display = 'block';
            }
        }
    }
    else {
        // If no claims were found, display a clear message
        const header = overlay.querySelector('.deepcite-claims-header small');
        if (header) {
            header.textContent = `No claims found on this page`;
        }
        // Add a single "no claims found" message to the overlay
        const noClaimsDiv = document.createElement('div');
        noClaimsDiv.className = 'deepcite-claim-item';
        noClaimsDiv.innerHTML = `
      <div class="deepcite-claim-text" style="text-align: center; padding: 15px;">
        No factual claims were detected on this page.
      </div>
    `;
        overlay.appendChild(noClaimsDiv);
        // Ensure overlay is visible
        overlay.classList.remove('closed', 'minimized');
        overlay.style.display = 'block';
        // Return early since there's nothing more to process
        return;
    }
}


================================================
File: /options.ts
================================================
interface Settings {
  exaKey: string;
  openaiKey: string;
  highlightsEnabled: boolean;
  sidebarEnabled: boolean;
  darkMode: boolean;
  excludedDomains: string[];
  maxVerificationsPerDay: number;
  enableCaching: boolean;
  cacheDuration: number;
  useLLMExtraction: boolean;
  usageCount: number;
  lastUsageReset: number;
}

// Test the Exa API key
async function testExaKey(key: string): Promise<boolean> {
  try {
    const response = await fetch('https://api.exa.ai/search', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${key}`
      },
      body: JSON.stringify({
        query: 'test query',
        numResults: 1
      })
    });
    return response.ok;
  } catch (error) {
    return false;
  }
}

// Test the OpenAI API key
async function testOpenAIKey(key: string): Promise<boolean> {
  try {
    const response = await fetch('https://api.openai.com/v1/models', {
      headers: {
        'Authorization': `Bearer ${key}`
      }
    });
    return response.ok;
  } catch (error) {
    return false;
  }
}

// Save settings to storage
async function saveSettings(): Promise<void> {
  const maxVerifications = (document.getElementById('maxVerifications') as HTMLInputElement).value;
  const cacheDuration = (document.getElementById('cacheDuration') as HTMLInputElement).value;
  
  // Get current usage stats to preserve them
  const currentStats = await chrome.storage.local.get(['usageCount', 'lastUsageReset']);
  
  const settings: Settings = {
    exaKey: (document.getElementById('exaKey') as HTMLInputElement).value,
    openaiKey: (document.getElementById('openaiKey') as HTMLInputElement).value,
    highlightsEnabled: (document.getElementById('highlightsEnabled') as HTMLInputElement).checked,
    sidebarEnabled: (document.getElementById('sidebarEnabled') as HTMLInputElement).checked,
    darkMode: (document.getElementById('darkMode') as HTMLInputElement).checked,
    excludedDomains: (document.getElementById('excludedDomains') as HTMLTextAreaElement)
      .value
      .split('\n')
      .map(d => d.trim())
      .filter(d => d),
    maxVerificationsPerDay: parseInt(maxVerifications || '10', 10),
    enableCaching: (document.getElementById('enableCaching') as HTMLInputElement).checked,
    cacheDuration: parseInt(cacheDuration || '7', 10),
    useLLMExtraction: (document.getElementById('useLLMExtraction') as HTMLInputElement).checked,
    usageCount: currentStats.usageCount || 0,
    lastUsageReset: currentStats.lastUsageReset || Date.now()
  };

  await chrome.storage.local.set(settings);
  
  // Notify content scripts of settings change
  const tabs = await chrome.tabs.query({});
  for (const tab of tabs) {
    if (tab.id) {
      chrome.tabs.sendMessage(tab.id, { type: 'SETTINGS_UPDATED', settings });
    }
  }
}

// Load settings from storage
async function loadSettings(): Promise<void> {
  const settings = await chrome.storage.local.get({
    exaKey: '',
    openaiKey: '',
    highlightsEnabled: true,
    sidebarEnabled: false,
    darkMode: false,
    excludedDomains: [],
    maxVerificationsPerDay: 10,
    enableCaching: true,
    cacheDuration: 7,
    usageCount: 0,
    lastUsageReset: Date.now(),
    useLLMExtraction: true
  });

  // Reset usage counter if it's a new day
  const today = new Date().toDateString();
  const lastReset = new Date(settings.lastUsageReset).toDateString();
  
  if (today !== lastReset) {
    console.log('New day detected, resetting usage counter');
    await chrome.storage.local.set({
      usageCount: 0,
      lastUsageReset: Date.now()
    });
    settings.usageCount = 0;
  }

  (document.getElementById('exaKey') as HTMLInputElement).value = settings.exaKey;
  (document.getElementById('openaiKey') as HTMLInputElement).value = settings.openaiKey;
  (document.getElementById('highlightsEnabled') as HTMLInputElement).checked = settings.highlightsEnabled;
  (document.getElementById('sidebarEnabled') as HTMLInputElement).checked = settings.sidebarEnabled;
  (document.getElementById('darkMode') as HTMLInputElement).checked = settings.darkMode;
  (document.getElementById('excludedDomains') as HTMLTextAreaElement).value = 
    settings.excludedDomains.join('\n');
  (document.getElementById('maxVerifications') as HTMLInputElement).value = 
    settings.maxVerificationsPerDay.toString();
  (document.getElementById('enableCaching') as HTMLInputElement).checked = 
    settings.enableCaching;
  (document.getElementById('cacheDuration') as HTMLInputElement).value = 
    settings.cacheDuration.toString();
  (document.getElementById('useLLMExtraction') as HTMLInputElement).checked = 
    settings.useLLMExtraction;
  
  // Update current usage display
  const currentUsageElement = document.getElementById('currentUsage');
  if (currentUsageElement) {
    currentUsageElement.textContent = settings.usageCount.toString();
  }
  
  // Conditionally disable LLM extraction toggle if OpenAI key is missing
  const openaiKeyField = document.getElementById('openaiKey') as HTMLInputElement;
  const useLLMExtractionField = document.getElementById('useLLMExtraction') as HTMLInputElement;
  
  if (!openaiKeyField.value) {
    useLLMExtractionField.checked = false;
    useLLMExtractionField.disabled = true;
    useLLMExtractionField.parentElement?.parentElement?.setAttribute('title', 'OpenAI API key required');
  } else {
    useLLMExtractionField.disabled = false;
    useLLMExtractionField.parentElement?.parentElement?.removeAttribute('title');
  }
}

// Update status message
function updateStatus(elementId: string, success: boolean, message: string): void {
  const element = document.getElementById(elementId);
  if (element) {
    element.textContent = message;
    element.className = `status ${success ? 'success' : 'error'}`;
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  loadSettings();

  // Test Exa API key
  document.getElementById('testExaKey')?.addEventListener('click', async () => {
    const key = (document.getElementById('exaKey') as HTMLInputElement).value;
    const success = await testExaKey(key);
    updateStatus('exaKeyStatus', success, 
      success ? '✓ API key is valid' : '✗ Invalid API key');
  });

  // Test OpenAI API key
  document.getElementById('testOpenAIKey')?.addEventListener('click', async () => {
    const key = (document.getElementById('openaiKey') as HTMLInputElement).value;
    const success = await testOpenAIKey(key);
    updateStatus('openaiKeyStatus', success, 
      success ? '✓ API key is valid' : '✗ Invalid API key');
      
    // Update LLM extraction toggle based on key validity
    const useLLMExtractionField = document.getElementById('useLLMExtraction') as HTMLInputElement;
    if (success) {
      useLLMExtractionField.disabled = false;
      useLLMExtractionField.parentElement?.parentElement?.removeAttribute('title');
    } else {
      useLLMExtractionField.checked = false;
      useLLMExtractionField.disabled = true;
      useLLMExtractionField.parentElement?.parentElement?.setAttribute('title', 'OpenAI API key required');
    }
  });
  
  // Listen for changes to the OpenAI key field
  document.getElementById('openaiKey')?.addEventListener('input', () => {
    const key = (document.getElementById('openaiKey') as HTMLInputElement).value;
    const useLLMExtractionField = document.getElementById('useLLMExtraction') as HTMLInputElement;
    
    if (key.trim() === '') {
      useLLMExtractionField.checked = false;
      useLLMExtractionField.disabled = true;
      useLLMExtractionField.parentElement?.parentElement?.setAttribute('title', 'OpenAI API key required');
    } else {
      useLLMExtractionField.disabled = false;
      useLLMExtractionField.parentElement?.parentElement?.removeAttribute('title');
    }
  });

  // Reset usage counter
  document.getElementById('resetUsage')?.addEventListener('click', async () => {
    await chrome.storage.local.set({
      usageCount: 0,
      lastUsageReset: Date.now()
    });
    
    // Update UI
    const currentUsageElement = document.getElementById('currentUsage');
    if (currentUsageElement) {
      currentUsageElement.textContent = '0';
    }
    
    updateStatus('saveStatus', true, 'Usage counter reset!');
    setTimeout(() => {
      const element = document.getElementById('saveStatus');
      if (element) element.textContent = '';
    }, 2000);
  });

  // Save settings
  document.getElementById('saveSettings')?.addEventListener('click', async () => {
    await saveSettings();
    updateStatus('saveStatus', true, 'Settings saved!');
    setTimeout(() => {
      const element = document.getElementById('saveStatus');
      if (element) element.textContent = '';
    }, 2000);
  });
}); 

================================================
File: /REFACTORING.md
================================================
# Athena DeepCite Refactoring Summary

This document summarizes the restructuring changes made in Iteration 6 to improve the organization and maintainability of the codebase.

## Directory Structure Changes

The codebase has been reorganized into a more modular structure:

```
/src/
  /extractors/     - Claim extraction strategies
    contentExtractor.ts  - Rule-based claim extraction
    llmExtractor.ts      - AI-powered claim extraction
  /handlers/       - Document type-specific handlers
    pdfHandler.ts        - PDF document processing
    pdfAnalyzer.ts       - PDF UI and analysis
    webPageHandler.ts    - Web page UI and analysis
  /utils/          - Shared utilities
    settingsManager.ts   - API key and settings management
  types.ts         - Core type definitions and interfaces
  background.ts    - Background service worker 
  contentScript.ts - Main entry point for content script
```

## Key Improvements

### 1. Separation of Concerns

- **PDFHandler**: Separated PDF-specific logic into its own handler
- **WebPageHandler**: Isolated web page-specific handling
- **Content Script**: Reduced to a lightweight coordinator that delegates to the appropriate handlers

### 2. Interface-based Design

- Created the `IClaimExtractor` interface to standardize claim extraction
- Both `ContentExtractor` and `LLMExtractor` now implement this interface
- This enables easy swapping or addition of new extraction strategies in the future

### 3. Centralized Configuration

- Created a `settingsManager.ts` utility to manage:
  - API key retrieval and storage
  - API endpoint configuration
  - Memory caching for better performance

### 4. Enhanced Message Handling

- Background script now uses a switch-case pattern for message routing
- Each message type has its own handler function
- Makes adding new message types easier in the future

### 5. Developer Tools

- Added ESLint for TypeScript
- Configured linting rules
- Added npm scripts for building and linting

### 6. Path Mapping

- Updated tsconfig.json with path aliases:
  - `@handlers/*`
  - `@extractors/*`
  - `@utils/*`
  - `@types`

## Benefits

1. **Maintainability**: Smaller, focused files are easier to understand and modify
2. **Extensibility**: New extractors or handlers can be added with minimal changes to existing code
3. **Team Development**: Clear separation makes it easier for multiple developers to work concurrently
4. **Testing**: Modular structure facilitates unit testing of individual components
5. **Documentation**: Code organization now better reflects the logical architecture

## Next Steps

1. Complete migration to the new structure:
   - Update any remaining imports to use path aliases
   - Ensure backward compatibility with existing features

2. Consider adding unit tests:
   - Jest or other testing frameworks can be added to test individual components

3. Future feature additions:
   - New message types can be added to background.ts
   - New extraction strategies can implement the IClaimExtractor interface
   - New document type handlers can be added to the handlers directory

